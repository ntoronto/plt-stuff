#lang typed/racket/base

(provide binary-split
         binary-split/pqa
         binary-split/qa binary-split/qa*
         binary-split/pq binary-split/pq*
         binary-split/pb binary-split/pb*
         binary-split/p binary-split/q)

;; Macros for creating binary splitting versions of certain power series. They
;; allow many fast algorithms to be expressed very concisely, which compute,
;; to arbitrary precision, functions like exp and cos, and constants like Ï€.
;; Efficiency is guaranteed for series that converge linearly or faster, when
;; used with a multiplication algorithm better than O(N^2) (where N is the
;; number of bits). FFT multiplication like in GMP certainly qualifies.

;; Adapted from the CLN source (which is LGPL).

(require racket/flonum)

;; =============================================================================
;; Binary split with known prefix length

;; binary-split: stx -> stx
;; Abstract binary splitting, as a macro. Given macros or functions a,b,p,q,
;; computes
;;
;;     \sum_{i=0}^{n-1} a(i)/b(i) \prod_{j=0}^i p(j)/q(j)
;;
;; using the binary splitting method. Functions a,b,p,q must be of type
;; Integer -> Type; the result will be of type (/ Type Type). The given Type
;; must be closed under addition and multiplication. This runs faster (by
;; a small constant factor) if a,b,p,q are macros, because Racket can
;; apply optimizations like (* b 1) => b and is forced to inline.
(define-syntax-rule (binary-split Type t+ t* p q a b n)
  (let ()
    (when (<= n 0)
      (error 'binary-split "series sum requires > 0 terms, not ~e" n))
    (define loop (binary-split-loop Type t+ t* p q a b))
    (define-values (_ Q B T)
      (loop 0 n))
    (values T (t* B Q))))

;; Specialized to when b(i) = 1 for all 0 <= i < n
(define-syntax-rule (binary-split/pqa Type t+ t* p q a n)
  (let ()
    (when (<= n 0)
      (error 'binary-split/pqa "series sum requires > 0 terms, not ~e" n))
    (define loop (binary-split-loop/pqa Type t+ t* p q a))
    (define-values (_ Q T)
      (loop 0 n))
    (values T Q)))

;; Specialized to when b(i) = 1 for all 0 <= i < n
(define-syntax-rule (binary-split/qa Type t+ t* q a n)
  (let ()
    (when (<= n 0)
      (error 'binary-split/qa "series sum requires > 0 terms, not ~e" n))
    (define loop (binary-split-loop/qa Type t+ t* q a))
    (define-values (Q T) (loop 0 n))
    (values T Q)))

;; Specialized to when b(i) = 1 for all 0 <= i < n
(define-syntax-rule (binary-split/qa* AType QType a+ a* q* aq* q a n)
  (let ()
    (when (<= n 0)
      (error 'binary-split/qa "series sum requires > 0 terms, not ~e" n))
    (define loop (binary-split-loop/qa* AType QType a+ a* q* aq* q a))
    (define-values (Q T) (loop 0 n))
    (values T Q)))

;; Specialized to when a(i) = b(i) = 1 for all 0 <= i < n
(define-syntax-rule (binary-split/pq Type t+ t* p q n)
  (let ()
    (when (<= n 0)
      (error 'binary-split/pq "series sum requires > 0 terms, not ~e" n))
    (define loop (binary-split-loop/pq Type t+ t* p q))
    (define-values (_ Q T)
      (loop 0 n))
    (values T Q)))

;; Specialized to when a(i) = b(i) = 1 for all 0 <= i < n
(define-syntax-rule (binary-split/pq* PType QType p+ p* q* pq* p q n)
  (let ()
    (when (<= n 0)
      (error 'binary-split/pq "series sum requires > 0 terms, not ~e" n))
    (define loop (binary-split-loop/pq* PType QType p+ p* q* pq* p q))
    (define-values (_ Q T)
      (loop 0 n))
    (values T Q)))

;; Specialized to when a(i) = q(i) = 1 for all 0 <= i < n
(define-syntax-rule (binary-split/pb* PType BType p+ p* b* pb* p b n)
  (let ()
    (when (<= n 0)
      (error 'binary-split/pq "series sum requires > 0 terms, not ~e" n))
    (define loop (binary-split-loop/pb* PType BType p+ p* b* pb* p b))
    (define-values (_ B T)
      (loop 0 n))
    (values T B)))

;; Specialized to when a(i) = q(i) = 1 for all 0 <= i < n
(define-syntax-rule (binary-split/pb Type + * p b n)
  (let ()
    (when (<= n 0)
      (error 'binary-split/pq "series sum requires > 0 terms, not ~e" n))
    (define loop (binary-split-loop/pb Type + * p b))
    (define-values (_ B T)
      (loop 0 n))
    (values T B)))

;; Specialized to when a(i) = b(i) = q(i) = 1 for all 0 <= i < n
(define-syntax-rule (binary-split/p Type t+ t* p n)
  (let ()
    (when (<= n 0)
      (error 'binary-split/p "series sum requires > 0 terms, not ~e" n))
    (define loop (binary-split-loop/p Type t+ t* p))
    (define-values (_ T)
      (loop 0 n))
    T))

;; Specialized to when a(i) = b(i) = p(i) = 1 for all 0 <= i < n
(define-syntax-rule (binary-split/q Type t+ t* one q n)
  (let ()
    (when (<= n 0)
      (error 'binary-split/q "series sum requires > 0 terms, not ~e" n))
    (define loop (binary-split-loop/q Type t+ t* one q))
    (define-values (Q T)
      (loop 0 n))
    (values T Q)))

;; =============================================================================
;; Actual computation (the above is just control)

(define-syntax-rule (binary-split-loop Type t+ t* p q a b)
  (let ()
    (: loop (Integer Integer -> (values Type Type Type Type)))
    (define (loop n1 n2)
      (case (- n2 n1)
        [(1)  (let ()
                (define p0  (p n1))
                (values p0 (q n1) (b n1) (* (a n1) p0)))]
        ; Cases 2,3,4 are not technically necessary, but having them results
        ; in up to 2x speedup
        [(2)  (let ()
                (define n1+1  (+ 1 n1))
                (define b0  (b n1))
                (define b1  (b n1+1))
                (define q1  (q n1+1))
                (define p0  (p n1))
                (define p01  (t* (p n1+1) p0))
                (values p01 (t* (q n1) q1) (t* b0 b1)
                        (t+ (t* (t* (t* (a n1) q1) b1) p0)
                            (t* (t* (a n1+1) b0) p01))))]
        [(3)  (let ()
                (define n1+1  (+ 1 n1))
                (define n1+2  (+ 2 n1))
                (define p0  (p n1))
                (define p01  (t* (p n1+1) p0))
                (define p012  (t* (p n1+2) p01))
                (define q2  (q n1+2))
                (define q12  (t* (q n1+1) q2))
                (define b0  (b n1))
                (define b1  (b n1+1))
                (define b2  (b n1+2))
                (define b12  (t* b1 b2))
                (values p012 (t* (q n1) q12) (t* b12 b0)
                        (t+ (t* (t* (t* (a n1) b12) q12) p0)
                            (t* b0 (t+ (t* (t* (t* (a n1+1) b2) q2) p01)
                                       (t* (t* (a n1+2) b1) p012))))))]
        [(4)  (let ()
                (define n1+1  (+ 1 n1))
                (define n1+2  (+ 2 n1))
                (define n1+3  (+ 3 n1))
                (define p0  (p n1))
                (define p01  (t* (p n1+1) p0))
                (define p012  (t* (p n1+2) p01))
                (define p0123  (t* (p n1+3) p012))
                (define q3  (q n1+3))
                (define q23  (t* (q n1+2) q3))
                (define q123  (t* (q n1+1) q23))
                (define b0  (b n1))
                (define b1  (b n1+1))
                (define b01  (t* b0 b1))
                (define b3  (b n1+3))
                (define b23  (t* (b n1+2) b3))
                (values p0123 (t* (q n1) q123) (t* b01 b23)
                        (t+ (t* b23 (t+ (t* (t* (t* (a n1) b1) q123) p0)
                                        (t* (t* (t* (a n1+1) b0) q23) p01)))
                            (t* b01 (t+ (t* (t* (t* (a n1+2) b3) q3) p012)
                                        (t* (t* (b n1+2) (a n1+3)) p0123))))))]
        [else  (let ()
                 (define m (arithmetic-shift (+ n1 n2) -1))
                 (define-values (Pl Ql Bl Tl) (loop n1 m))
                 (define-values (Pr Qr Br Tr) (loop m n2))
                 (values (t* Pl Pr) (t* Ql Qr) (t* Bl Br)
                         (t+ (t* (t* Br Qr) Tl) (t* (t* Bl Pl) Tr))))]))
    loop))

(define-syntax-rule (binary-split-loop/pqa Type t+ t* p q a)
  (let ()
    (: loop (Integer Integer -> (values Type Type Type)))
    (define (loop n1 n2)
      (case (- n2 n1)
        [(1)  (let ()
                (define p0  (p n1))
                (values p0 (q n1) (* (a n1) p0)))]
        [(2)  (let ()
                (define n1+1  (+ 1 n1))
                (define q1  (q n1+1))
                (define p0  (p n1))
                (define p01  (t* (p n1+1) p0))
                (values p01 (t* (q n1) q1)
                        (t+ (t* (t* (a n1) q1) p0)
                            (t* (a n1+1) p01))))]
        [(3)  (let ()
                (define n1+1  (+ 1 n1))
                (define n1+2  (+ 2 n1))
                (define p0  (p n1))
                (define p01  (t* (p n1+1) p0))
                (define p012  (t* (p n1+2) p01))
                (define q2  (q n1+2))
                (define q12  (t* (q n1+1) q2))
                (values p012 (t* (q n1) q12)
                        (t+ (t* (t* (a n1) q12) p0)
                            (t+ (t* (t* (a n1+1) q2) p01)
                                (t* (a n1+2) p012)))))]
        [(4)  (let ()
                (define n1+1  (+ 1 n1))
                (define n1+2  (+ 2 n1))
                (define n1+3  (+ 3 n1))
                (define p0  (p n1))
                (define p01  (t* (p n1+1) p0))
                (define p012  (t* (p n1+2) p01))
                (define p0123  (t* (p n1+3) p012))
                (define q3  (q n1+3))
                (define q23  (t* (q n1+2) q3))
                (define q123  (t* (q n1+1) q23))
                (values p0123 (t* (q n1) q123)
                        (t+ (t+ (t* (t* (a n1) q123) p0)
                                (t* (t* (a n1+1) q23) p01))
                            (t+ (t* (t* (a n1+2) q3) p012)
                                (t* (a n1+3) p0123)))))]
        [else  (let ()
                 (define m (arithmetic-shift (+ n1 n2) -1))
                 (define-values (Pl Ql Tl) (loop n1 m))
                 (define-values (Pr Qr Tr) (loop m n2))
                 (values (t* Pl Pr) (t* Ql Qr)
                         (t+ (t* Qr Tl) (t* Pl Tr))))]))
    loop))

(define-syntax-rule (binary-split-loop/qa Type t+ t* q a)
  (let ()
    (: loop (Integer Integer -> (values Type Type)))
    (define (loop n1 n2)
      (case (- n2 n1)
        [(1)  (let ()
                (values (q n1) (a n1)))]
        [(2)  (let ()
                (define n1+1  (+ 1 n1))
                (define q1  (q n1+1))
                (values (t* (q n1) q1)
                        (t+ (t* (a n1) q1) (a n1+1))))]
        [(3)  (let ()
                (define n1+1  (+ 1 n1))
                (define n1+2  (+ 2 n1))
                (define q2  (q n1+2))
                (define q12  (t* (q n1+1) q2))
                (values (t* (q n1) q12)
                        (t+ (t* (a n1) q12)
                            (t+ (t* (a n1+1) q2) (a n1+2)))))]
        [(4)  (let ()
                (define n1+1  (+ 1 n1))
                (define n1+2  (+ 2 n1))
                (define n1+3  (+ 3 n1))
                (define q3  (q n1+3))
                (define q23  (t* (q n1+2) q3))
                (define q123  (t* (q n1+1) q23))
                (values (t* (q n1) q123)
                        (t+ (t+ (t* (a n1) q123)
                                (t* (a n1+1) q23))
                            (t+ (t* (a n1+2) q3) (a n1+3)))))]
        [else  (let ()
                 (define m (arithmetic-shift (+ n1 n2) -1))
                 (define-values (Ql Tl) (loop n1 m))
                 (define-values (Qr Tr) (loop m n2))
                 (values (t* Ql Qr) (t+ (t* Qr Tl) Tr)))]))
    loop))

(define-syntax-rule (binary-split-loop/qa* AType QType a+ a* q* aq* q a)
  (let ()
    (: loop (Integer Integer -> (values QType AType)))
    (define (loop n1 n2)
      (case (- n2 n1)
        [(1)  (let ()
                (values (q n1) (a n1)))]
        [(2)  (let ()
                (define n1+1  (+ 1 n1))
                (define q1  (q n1+1))
                (values (q* (q n1) q1)
                        (a+ (aq* (a n1) q1) (a n1+1))))]
        [(3)  (let ()
                (define n1+1  (+ 1 n1))
                (define n1+2  (+ 2 n1))
                (define q2  (q n1+2))
                (define q12  (q* (q n1+1) q2))
                (values (q* (q n1) q12)
                        (a+ (aq* (a n1) q12)
                            (a+ (aq* (a n1+1) q2) (a n1+2)))))]
        [(4)  (let ()
                (define n1+1  (+ 1 n1))
                (define n1+2  (+ 2 n1))
                (define n1+3  (+ 3 n1))
                (define q3  (q n1+3))
                (define q23  (q* (q n1+2) q3))
                (define q123  (q* (q n1+1) q23))
                (values (q* (q n1) q123)
                        (a+ (a+ (aq* (a n1) q123)
                                (aq* (a n1+1) q23))
                            (a+ (aq* (a n1+2) q3) (a n1+3)))))]
        [else  (let ()
                 (define m (arithmetic-shift (+ n1 n2) -1))
                 (define-values (Ql Tl) (loop n1 m))
                 (define-values (Qr Tr) (loop m n2))
                 (values (q* Ql Qr) (a+ (aq* Tl Qr) Tr)))]))
    loop))

(define-syntax-rule (binary-split-loop/pq Type t+ t* p q)
  (let ()
    (: loop (Integer Integer -> (values Type Type Type)))
    (define (loop n1 n2)
      (case (- n2 n1)
        [(1)  (let ()
                (define p0  (p n1))
                (values p0 (q n1) p0))]
        [(2)  (let ()
                (define n1+1  (+ 1 n1))
                (define p0  (p n1))
                (define p01  (t* (p n1+1) p0))
                (define q1  (q n1+1))
                (values p01 (t* (q n1) q1) (t+ (t* q1 p0) p01)))]
        [(3)  (let ()
                (define n1+1  (+ 1 n1))
                (define n1+2  (+ 2 n1))
                (define p0  (p n1))
                (define p01  (t* (p n1+1) p0))
                (define p012  (t* (p n1+2) p01))
                (define q2  (q n1+2))
                (define q12  (t* (q n1+1) q2))
                (values p012 (t* (q n1) q12)
                        (t+ (t+ (t* q12 p0) (t* q2 p01)) p012)))]
        [(4)  (let ()
                (define n1+1  (+ 1 n1))
                (define n1+2  (+ 2 n1))
                (define n1+3  (+ 3 n1))
                (define p0  (p n1))
                (define p01  (t* (p n1+1) p0))
                (define p012  (t* (p n1+2) p01))
                (define p0123  (t* (p n1+3) p012))
                (define q3  (q n1+3))
                (define q23  (t* (q n1+2) q3))
                (define q123  (t* (q n1+1) q23))
                (values p0123 (t* (q n1) q123)
                        (t+ (t+ (t+ (t* q123 p0) (t* q23 p01)) (t* q3 p012)) p0123)))]
        [else  (let ()
                 (define m (arithmetic-shift (+ n1 n2) -1))
                 (define-values (Pl Ql Tl) (loop n1 m))
                 (define-values (Pr Qr Tr) (loop m n2))
                 (values (t* Pl Pr) (t* Ql Qr)
                         (t+ (t* Qr Tl) (t* Pl Tr))))]))
    loop))

(define-syntax-rule (binary-split-loop/pq* PType QType p+ p* q* pq* p q)
  (let ()
    (: loop (Integer Integer -> (values PType QType PType)))
    (define (loop n1 n2)
      (case (- n2 n1)
        [(1)  (let ()
                (define p0  (p n1))
                (values p0 (q n1) p0))]
        [(2)  (let ()
                (define n1+1  (+ 1 n1))
                (define p0  (p n1))
                (define p01  (p* (p n1+1) p0))
                (define q1  (q n1+1))
                (values p01 (q* (q n1) q1) (p+ (pq* p0 q1) p01)))]
        [(3)  (let ()
                (define n1+1  (+ 1 n1))
                (define n1+2  (+ 2 n1))
                (define p0  (p n1))
                (define p01  (p* (p n1+1) p0))
                (define p012  (p* (p n1+2) p01))
                (define q2  (q n1+2))
                (define q12  (q* (q n1+1) q2))
                (values p012 (q* (q n1) q12)
                        (p+ (p+ (pq* p0 q12) (pq* p01 q2)) p012)))]
        [(4)  (let ()
                (define n1+1  (+ 1 n1))
                (define n1+2  (+ 2 n1))
                (define n1+3  (+ 3 n1))
                (define p0  (p n1))
                (define p01  (p* (p n1+1) p0))
                (define p012  (p* (p n1+2) p01))
                (define p0123  (p* (p n1+3) p012))
                (define q3  (q n1+3))
                (define q23  (q* (q n1+2) q3))
                (define q123  (q* (q n1+1) q23))
                (values p0123 (q* (q n1) q123)
                        (p+ (p+ (p+ (pq* p0 q123) (pq* p01 q23)) (pq* p012 q3)) p0123)))]
        [else  (let ()
                 (define m (arithmetic-shift (+ n1 n2) -1))
                 (define-values (Pl Ql Tl) (loop n1 m))
                 (define-values (Pr Qr Tr) (loop m n2))
                 (values (p* Pl Pr) (q* Ql Qr)
                         (p+ (pq* Tl Qr) (p* Pl Tr))))]))
    loop))

(define-syntax-rule (binary-split-loop/pb* PType BType p+ p* b* pb* p b)
  (let ()
    (: loop (Integer Integer -> (values PType BType PType)))
    (define (loop n1 n2)
      (case (- n2 n1)
        [(1)  (let ()
                (define p0  (p n1))
                (values p0 (b n1) p0))]
        ; Cases 2,3,4 are not technically necessary, but having them results
        ; in up to 2x speedup
        [(2)  (let ()
                (define n1+1  (+ 1 n1))
                (define b0  (b n1))
                (define b1  (b n1+1))
                (define p0  (p n1))
                (define p01  (p* (p n1+1) p0))
                (values p01 (b* b0 b1)
                        (p+ (pb* p0 b1) (pb* p01 b0))))]
        [(3)  (let ()
                (define n1+1  (+ 1 n1))
                (define n1+2  (+ 2 n1))
                (define p0  (p n1))
                (define p01  (p* (p n1+1) p0))
                (define p012  (p* (p n1+2) p01))
                (define b0  (b n1))
                (define b1  (b n1+1))
                (define b2  (b n1+2))
                (define b12  (b* b1 b2))
                (values p012 (b* b12 b0)
                        (p+ (pb* p0 b12)
                            (pb* (p+ (pb* p01 b2) (pb* p012 b1)) b0))))]
        [(4)  (let ()
                (define n1+1  (+ 1 n1))
                (define n1+2  (+ 2 n1))
                (define n1+3  (+ 3 n1))
                (define p0  (p n1))
                (define p01  (p* (p n1+1) p0))
                (define p012  (p* (p n1+2) p01))
                (define p0123  (p* (p n1+3) p012))
                (define b0  (b n1))
                (define b1  (b n1+1))
                (define b01  (b* b0 b1))
                (define b3  (b n1+3))
                (define b23  (b* (b n1+2) b3))
                (values p0123 (b* b01 b23)
                        (p+ (pb* (p+ (pb* p0 b1) (pb* p01 b0)) b23)
                            (pb* (p+ (pb* p012 b3) (pb* p0123 (b n1+2))) b01))))]
        [else  (let ()
                 (define m (arithmetic-shift (+ n1 n2) -1))
                 (define-values (Pl Bl Tl) (loop n1 m))
                 (define-values (Pr Br Tr) (loop m n2))
                 (values (p* Pl Pr) (b* Bl Br)
                         (p+ (pb* Tl Br) (p* (pb* Pl Bl) Tr))))]))
    loop))

(define-syntax-rule (binary-split-loop/pb Type t+ t* p b)
  (let ()
    (: loop (Integer Integer -> (values Type Type Type)))
    (define (loop n1 n2)
      (case (- n2 n1)
        [(1)  (let ()
                (define p0  (p n1))
                (values p0 (b n1) p0))]
        ; Cases 2,3,4 are not technically necessary, but having them results
        ; in up to 2x speedup
        [(2)  (let ()
                (define n1+1  (+ 1 n1))
                (define b0  (b n1))
                (define b1  (b n1+1))
                (define p0  (p n1))
                (define p01  (t* (p n1+1) p0))
                (values p01 (t* b0 b1)
                        (t+ (t* b1 p0) (t* b0 p01))))]
        [(3)  (let ()
                (define n1+1  (+ 1 n1))
                (define n1+2  (+ 2 n1))
                (define p0  (p n1))
                (define p01  (t* (p n1+1) p0))
                (define p012  (t* (p n1+2) p01))
                (define b0  (b n1))
                (define b1  (b n1+1))
                (define b2  (b n1+2))
                (define b12  (t* b1 b2))
                (values p012 (t* b12 b0)
                        (t+ (t* b12 p0)
                            (t* b0 (t+ (t* b2 p01) (t* b1 p012))))))]
        [(4)  (let ()
                (define n1+1  (+ 1 n1))
                (define n1+2  (+ 2 n1))
                (define n1+3  (+ 3 n1))
                (define p0  (p n1))
                (define p01  (t* (p n1+1) p0))
                (define p012  (t* (p n1+2) p01))
                (define p0123  (t* (p n1+3) p012))
                (define b0  (b n1))
                (define b1  (b n1+1))
                (define b01  (t* b0 b1))
                (define b3  (b n1+3))
                (define b23  (t* (b n1+2) b3))
                (values p0123 (t* b01 b23)
                        (t+ (t* b23 (t+ (t* b1 p0)
                                        (t* b0 p01)))
                            (t* b01 (t+ (t* b3 p012)
                                        (t* (b n1+2) p0123))))))]
        [else  (let ()
                 (define m (arithmetic-shift (+ n1 n2) -1))
                 (define-values (Pl Bl Tl) (loop n1 m))
                 (define-values (Pr Br Tr) (loop m n2))
                 (values (t* Pl Pr) (t* Bl Br)
                         (t+ (t* Br Tl) (t* (t* Bl Pl) Tr))))]))
    loop))

(define-syntax-rule (binary-split-loop/p Type t+ t* p)
  (let ()
    (: loop (Integer Integer -> (values Type Type)))
    (define (loop n1 n2)
      (case (- n2 n1)
        [(1)  (let ()
                (define p0  (p n1))
                (values p0 p0))]
        [(2)  (let ()
                (define p0  (p n1))
                (define p01  (t* (p (+ 1 n1)) p0))
                (values p01 (t+ p0 p01)))]
        [(3)  (let ()
                (define p0  (p n1))
                (define p01  (t* p0 (p (+ 1 n1))))
                (define p012  (t* p01 (p (+ 2 n1))))
                (values p012 (t+ (t+ p0 p01) p012)))]
        [(4)  (let ()
                (define p0  (p n1))
                (define p01  (t* (p (+ 1 n1)) p0))
                (define p012  (t* (p (+ 2 n1)) p01))
                (define p0123  (t* (p (+ 3 n1)) p012))
                (values p0123 (t+ (t+ (t+ p0 p01) p012) p0123)))]
        [else  (let ()
                 (define m (arithmetic-shift (+ n1 n2) -1))
                 (define-values (Pl Tl) (loop n1 m))
                 (define-values (Pr Tr) (loop m n2))
                 (values (t* Pl Pr) (t+ Tl (t* Pl Tr))))]))
    loop))

(define-syntax-rule (binary-split-loop/q Type t+ t* one q)
  (let ()
    (: loop (Integer Integer -> (values Type Type)))
    (define (loop n1 n2)
      (case (- n2 n1)
        [(1)  (let ()
                (values (q n1) one))]
        [(2)  (let ()
                (define q1  (q (+ 1 n1)))
                (values (t* (q n1) q1) (t+ q1 one)))]
        [(3)  (let ()
                (define q2  (q (+ 2 n1)))
                (define q12  (t* (q (+ 1 n1)) q2))
                (values (t* (q n1) q12) (t+ (t+ q12 q2) one)))]
        [(4)  (let ()
                (define q3  (q (+ 3 n1)))
                (define q23  (t* (q (+ 2 n1)) q3))
                (define q123  (t* (q (+ 1 n1)) q23))
                (values (t* (q n1) q123) (t+ (t+ (t+ q123 q23) q3) one)))]
        [else  (let ()
                 (define m (arithmetic-shift (+ n1 n2) -1))
                 (define-values (Ql Tl) (loop n1 m))
                 (define-values (Qr Tr) (loop m n2))
                 (values (t* Ql Qr) (t+ (t* Qr Tl) Tr)))]))
    loop))
