%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\input{local-macros.tex}

\mathversion{sans}

\newcommand{\arrow}{\rightsquigarrow}

\newcommand{\restrict}[1]{\lvert_{#1}}
\newcommand{\pto}{\rightharpoonup}
\newcommand{\Univ}{\mathbb{U}}
\newcommand{\Un}{\mathcal{U}}

\newcommand{\arrowlift}{\ensuremath{lift}}
\newcommand{\arrowarr}{\ensuremath{arr}}
\newcommand{\arrowcomp}{\ensuremath{{>}\mspace{-6mu}{>}\mspace{-6mu}{>}}}
\newcommand{\arrowpair}{\ensuremath{\mathit{\&\mspace{-7.5mu}\&\mspace{-7.5mu}\&}}}
%\newcommand{\arrowpair}{\ensuremath{pair}}
\newcommand{\arrowif}{\ensuremath{if}}
\newcommand{\arrowlazy}{\ensuremath{lazy}}
\newcommand{\arrowapp}{\ensuremath{app}}
\newcommand{\arrowrun}{\ensuremath{run}}

\newcommand{\arrbot}{\arrowarr_\bot}
\newcommand{\compbot}{\arrowcomp_\bot}
\newcommand{\pairbot}{\arrowpair_\bot}
\newcommand{\ifbot}{\arrowif_\bot}

\newcommand{\map}{_\mathrm{map}}
\DeclareMathOperator{\mapto}{\arrow_{\mspace{-21mu}\map}}
%\DeclareMathOperator{\eqmap}{\mbox{\ensuremath{=_{\mspace{-19mu}\map}}}}
\newcommand{\liftmap}{\arrowlift\map}
\newcommand{\arrmap}{\arrowarr\map}
\newcommand{\compmap}{\arrowcomp\map}
\newcommand{\pairmap}{\arrowpair\map}
\newcommand{\ifmap}{\arrowif\map}

\newcommand{\pre}{_\mathrm{pre}}
\DeclareMathOperator{\preto}{\arrow_{\mspace{-19mu}\pre}}
%\DeclareMathOperator{\eqpre}{=_{\mspace{-17mu}\pre}}
\newcommand{\liftpre}{\arrowlift\pre}
\newcommand{\arrpre}{\arrowarr\pre}
\newcommand{\comppre}{\arrowcomp\pre}
\newcommand{\pairpre}{\arrowpair\pre}
\newcommand{\ifpre}{\arrowif\pre}

\newcommand{\prepto}{\pto_{\mspace{-19mu}\pre}}


\begin{document}

\conferenceinfo{POPL '14}{January 22-24, 2014, San Diego, CA, USA}
\copyrightyear{2014}
\copyrightdata{[to be supplied]} 

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Running Probabilistic Programs Backward}
%\subtitle{Subtitle Text, if any}

\authorinfo{Neil Toronto \and Jay McCarthy}
           {PLT @ Brigham Young University}
           {ntoronto@racket-lang.org \and jay@cs.byu.edu}
%\authorinfo{Chris Grant}
%           {Brigham Young University}
%           {grant@math.byu.edu}
\maketitle

\begin{abstract}
XXX
\end{abstract}

\category{XXX-CR-number}{XXX-subcategory}{XXX-third-level}

\terms
XXX, XXX

\keywords
XXX, XXX

TODO: equivalence relation for \lzfclang terms, that at least handles divergence

\section{Introduction}

\begin{enumerate}
	\item Define the \emph{bottom arrow}, type $X \tto Y_\bot$, a compilation target for first-order functions that may raise errors.
	\item Derive the \emph{mapping arrow} from the bottom arrow, type $X \mapto Y$. Its instances return extensional functions, or mappings, that compute the same values as their corresponding bottom arrow computations, but have observable domains.
	\item Derive the \emph{preimage arrow} from the mapping arrow, type $X \preto Y$. Instances compute preimages under their corresponding mapping arrow instances.
	\item Derive \emph{XXX} from the preimage arrow. Instances compute conservative approximations of the preimages computed by their corresponding preimage arrow instances.
\end{enumerate}
Only the first and last artifacts---the bottom arrow and the XXX---can be implemented.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Mathematics and Metalanguage}

From here on, significant terms are introduced in \keyword{bold}, and significant terms we invent are introduced in \mykeyword{bold italics}.

We write all of the mathematics in this paper in \lzfclang~\cite{cit:toronto-2012flops-lzfc}, an untyped, call-by-value lambda calculus designed for manually deriving computable programs from contemporary mathematics.

Contemporary mathematics is generally done in \keyword{ZFC}: \keyword{Zermelo-Fraenkel} set theory extended with the axiom of \keyword{Choice} (equivalently unique \keyword{Cardinality}).
ZFC has only first-order functions and no general recursion, which makes implementing a language defined by a transformation into contemporary mathematics quite difficult.
The problem is exacerbated if implementing the language requires approximation.
Targeting \lzfclang instead allows creating a precise mathematical specification and deriving an approximating implementation without changing languages.

In \lzfclang, essentially every set is a value, as well as every lambda and every set of lambdas.
All operations, including operations on infinite sets, are assumed to complete instantly if they terminate.\footnote{An
example of a nonterminating \lzfclang function is one that attempts to decide whether other \lzfclang programs halt.}

Almost everything definable in contemporary mathematics can be formally defined by a finite \lzfclang program, except objects that most mathematicians would agree are nonconstructive.
More precisely, any object that \emph{must} be defined by a statement of existence and uniqueness without giving a bounding set is not definable by a \emph{finite} \lzfclang program.

Because \lzfclang includes an inner model of ZFC, essentially every contemporary theorem applies to \lzfclang's set values without alteration.
Further, proofs about \lzfclang's set values apply to contemporary mathematical objects.\footnote{Assuming the existence of an inaccessible cardinal.}

In \lzfclang, algebraic data structures are encoded as sets; e.g. a \mykeyword{primitive ordered pair} of $x$ and $y$ is $\set{\set{x},\set{x,y}}$.
Only the \emph{existence} of encodings into sets is important, as it means data structures inherit a defining characteristic of sets: strictness.
More precisely, the lengths of paths to data structure leaves is unbounded, but each path must be finite.
Less precisely, data may be ``infinitely wide'' (such as $\Re$) but not ``infinitely tall'' (such as infinite trees and lists).

We assume data structures, including pairs, are encoded as \emph{primitive} ordered pairs with the first element a unique tag, so that they can be distinguished by checking tags.
Accessors such as $fst$ and $snd$ are trivial to define.

\lzfclang is untyped so its users can define an auxiliary type system that best suits their application area.
For this work, we use an informal, manually checked, polymorphic type system characterized by these rules:
\begin{itemize}
	\item A free lowercase type variable is universally quantified.
	\item A free uppercase type variable is a set.
	\item A set denotes a member of that set.
	\item $x \tto y$ denotes a partial function.
	\item $\pair{x,y}$ denotes a pair of values with types $x$ and $y$.
	\item $Set~x$ denotes a set with members of type $x$.
\end{itemize}
The type $Set~A$ denotes the same values as the powerset $\powerset~A$, or \emph{subsets} of $A$.
Similarly, the type $\pair{A,B}$ denotes the same values as the product set $A \times B$.

We write \lzfclang programs in heavily sugared $\lambda$-calculus syntax, with an $if$ expression and these additional primitives:
\begin{equation}
\begin{aligned}
	\begin{aligned}
		true &: Bool \\
		false &: Bool \\
		\emptyset &: Set~x \\
		\omega &: Ord \\
		take &: Set~x \tto x \\
	\end{aligned}
	&\tab
	\begin{aligned}
		(\in) &: x \tto Set~x \tto Bool \\
		\powerset &: Set~x \tto Set~(Set~x) \\
		\U &: Set~(Set~x) \tto Set~x \\
		image &: (x \tto y) \tto Set~x \tto Set~y \\
		card &: Set~x \tto Ord \\
	\end{aligned} \\
\end{aligned}
\label{eqn:lzfc-prims}
\end{equation}
Shortly, $\emptyset$ is the empty set, $\omega$ is the cardinality of the natural numbers, $take$ removes the member from a singleton set, $(\in)$ is an infix operator that decides membership, $\powerset$ returns all the subsets of a set, $\U$ returns the union of a set of sets, $image$ applies a function to each member of a set and returns the set of return values, and $card$ returns the cardinality of a set.

We assume literal set notation such as $\set{0,1,2}$ is already defined in terms of set primitives.

\subsection{Internal and External Equality}

Set theory extends first-order logic with an axiom that defines equality to be extensional, and with axioms that ensure the existence of sets in the domain of discourse.
\lzfclang is defined the same way as any other operational $\lambda$-calculus: by (conservatively) extending the domain of discourse with expressions and defining a reduction relation.

While \lzfclang does not have an equality primitive, set theory's extensional equality can be recovered internally using $(\in)$.
\emph{Internal} extensional equality is defined by
\begin{equation}
	x = y \ := \ x \in \set{y}
\end{equation}
which means
\begin{equation}
	(=) \ := \ \fun{x}\fun{y}{x \in \set{y}}
\end{equation}
Thus, $1 = 1$ reduces to $1 \in \set{1}$, which reduces to $true$.\footnote{Technically, \lzfclang has a big-step semantics, and $1 \in \set{1}$ can be extracted from the derivation tree for $1 = 1$.}
Because of the particular way \lzfclang's lambda terms are defined, for two lambda terms $f$ and $g$, $f = g$ reduces to $true$ when $f$ and $g$ are structurally identical modulo renaming.
For example, $(\fun{x}{x}) = (\fun{y}{y})$ reduces to $true$, but $(\fun{x}{2}) = (\fun{x}{1+1})$ reduces to $false$.

We understand any \lzfclang term $\mathit{e}$ used as a truth statement as shorthand for ``$\mathit{e}$ reduces to $true$.''
Therefore, while the terms $\set{(\fun{x}{x})~1,\,1}$ and $\set{1}$ are (externally, extensionally) unequal, we can say that $\set{(\fun{x}{x})~1,\,1} = \set{1}$.

Any truth statement $\mathit{e}$ implies that $\mathit{e}$ converges.
We sometimes do not want this, particularly when we want to say that $\mathit{e_1}$ and $\mathit{e_2}$ are equivalent when they both diverge.
In these cases, we use a slightly weaker equivalence.

\begin{definition}[observational equivalence]
Two \lzfclang terms $\mathit{e_1}$ and $\mathit{e_2}$ are \keyword{observationally equivalent}, written $\mathit{e_1} \equiv \mathit{e_2}$, when $\mathit{e_1} = \mathit{e_2}$ or both $\mathit{e_1}$ and $\mathit{e_2}$ diverge.
\end{definition}

It could be helpful to introduce even coarser notions of equivalence, such as applicative or logical bisimilarity.
However, we do not want internal equality and external equivalence to differ too much.
We therefore introduce type-specific notions of equivalence as needed.

\subsection{Additional Functions and Forms}

XXX: lambda syntactic sugar: automatic currying (including the two-argument primitives $(\in)$ and $image$), matching, sectioning rules

XXX: set syntactic sugar: set comprehensions, cardinality, indexed unions

XXX: functions: $\u$, $\i$, $\w$, $\subseteq$

\begin{equation}
\begin{aligned}
	&(\uplus) : Set~x \tto Set~x \tto Set~x \\
	&A \uplus B \ := \ if~(A \i B = \emptyset)~(A \u B)~(take~\emptyset)
\end{aligned}
\end{equation}

XXX: logic: logical operators and quantifiers

In set theory, functions are encoded as sets of input-output pairs.
The increment function for the natural numbers, for example, is $\set{\pair{0,1},\pair{1,2},\pair{2,3},...}$.
To distinguish these hash tables from lambdas, we call them \mykeyword{mappings}, and use the word \keyword{function} for either a lambda or a mapping.
For convenience, as with lambdas, we use adjacency (i.e. $(f~x)$) to apply mappings.

The set $X \pto Y$ contains all the \emph{partial} mappings from $X$ to $Y$.
For example, $X \pto Y$ is the return type for the restriction function:
\begin{equation}
\begin{aligned}
	&(\cdot)\restrict{(\cdot)}\ : (X \tto Y) \tto Set~X \tto (X \pto Y) \\
	&f\restrict{A} \ := \ image~(\fun{x}{(x, f~x)})~A
\end{aligned}
\end{equation}
which converts a lambda or a mapping to a mapping with domain $A \subseteq X$.
To create mappings using lambda syntax, we define $\fun{x \in A}{e}$ as shorthand for $(\fun{x}{e})\restrict{A}$.

Figure~\ref{fig:mapping-defs} defines more operations on partial mappings: $domain$, $range$, $preimage$, pairing, composition, and disjoint union.
The latter three are particularly important in the preimage arrow's derivation, and $preimage$ is critical in measure theory's account of probability.

\begin{figure*}[t]\centering
\begin{align*}
\begin{aligned}[t]
	&\begin{aligned}[t]
		&domain : (X \pto Y) \tto Set~X \\
		&domain \ := \ image~fst \\
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}[t]
		&range : (X \pto Y) \tto Set~Y \\
		&range \ := \ image~snd
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}[t]
		&preimage : (X \pto Y) \tto Set~Y \tto Set~X \\
		&preimage~f~B \ :=\ \setb{x \in domain~f}{f~x \in B}
	\end{aligned} \\
\end{aligned}
&\tab\tab\tab
\begin{aligned}[t]
	&\begin{aligned}[t]
		&\pair{\cdot,\cdot}\map : (X \pto Y_1) \tto (X \pto Y_2) \tto (X \pto Y_1 \times Y_2) \\
		&\pair{g_1,g_2}\map \ := \ 
			\lzfclet{
				A & (domain~g_1) \i (domain~g_2)
			}{\fun{x \in A}{\pair{g_1~x,g_2~x}}}
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}[t]
		&(\circ\map) : (Y \pto Z) \tto (X \pto Y) \tto (X \pto Z) \\
		&g_2 \circ\map g_1 \ := \ 
			\lzfclet{
				A & preimage~g_1~(domain~g_2)
			}{\fun{x \in A}{g_2~(g_1~x)}}
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}[t]
		&(\uplus\map) : (X \pto Y) \tto (X \pto Y) \tto (X \pto Y) \\
		&g_1 \uplus\map g_2 \ := \ 
			\lzfclet{
				A & (domain~g_1) \uplus (domain~g_2)
			}{\fun{x \in A}{if~(x \in domain~g_1)~(g_1~x)~(g_2~x)}}
	\end{aligned}
\end{aligned}
\end{align*}
\hrule
\caption{Operations on mappings.}
\label{fig:mapping-defs}
\end{figure*}

XXX: lazy mappings

\begin{comment}
\subsection{Ordinal Numbers and Transfinite Recursion}

The \keyword{ordinal numbers}, or values of type $Ord$, are an extension of the natural numbers to infinite lengths.
Ordinals are typically defined as the smallest sets that contain all their predecessors; e.g. the first four are
\begin{equation}
\begin{aligned}
	\begin{aligned}
		0 &\ := \ \emptyset \\
		1 &\ := \ \set{0}
	\end{aligned}
	&\tab\tab
	\begin{aligned}
		2 &\ := \ \set{0,1} \\
		3 &\ := \ \set{0,1,2}
	\end{aligned}
\end{aligned}
\end{equation}
The smallest infinite ordinal $\omega$ is the set of all finite ordinals.
Other infinite ordinals are defined in terms of $\omega$:
\begin{equation}
\begin{aligned}
	\omega &\ := \ \set{0,1,2,3,...} \\
	\omega+1 &\ := \ \set{0,1,2,3,...,\omega} \\
	\omega+2 &\ := \ \set{0,1,2,3,...,\omega,\omega+1} \\
	\omega+\omega &\ := \ \set{0,1,2,3,...,\omega,\omega+1,\omega+2,...}
\end{aligned}
\end{equation}
The above sets are all countable, meaning that their cardinality is $\omega$.
Generally, any ordinal $\alpha$ for which $\alpha = |\alpha|$ is also called a \keyword{cardinal number}.%\footnote{Think of ordinals as lengths of ordered collections, and cardinals as sizes of unordered collections.}

Ordinals are totally ordered by membership; i.e. $\beta < \alpha$ is equivalent to $\beta \in \alpha$.
Ordinals with an immediate predecessor (such as $3$ and $\omega+2$) are called \keyword{successor ordinals}.
Nonzero ordinals without an immediate predecessor (roughly, those whose literal representations end in ``$...$'') are called \keyword{limit ordinals}.

Limit ordinals allow writing terminating functions that recur infinitely many times.
Suppose we wanted a function that recursively generates all the integral successors of $0.5$.
Consider this first attempt, which can be written in any Turing-equivalent language:
\begin{equation}
\begin{aligned}
	&succs : \omega \tto Set~\Re \tto Set~\Re \\
	&\lzfcsplit{
		&succs~n~A \ := \ \\
		&\tab\lzfccase{n}{
			0 & A \\
			m+1 & A \u (image~(+~1.0)~(succs~m~A))
		}
	}
\end{aligned}
\end{equation}
This unfold over finite ordinals generates prefixes such as
\begin{equation}
\begin{aligned}
	succs~0~\set{0.5} &\ = \ \set{0.5} \\
	succs~1~\set{0.5} &\ = \ \set{0.5, 1.5} \\
	succs~2~\set{0.5} &\ = \ \set{0.5, 1.5, 2.5}
\end{aligned}
\end{equation}
but will never generate the full set of integral successors.

To close $\set{0.5}$ under increment, we can use \keyword{transfinite recursion}: unfolding over ordinals as above, but using an additional inductive case for limit ordinals:
\begin{equation}
\begin{aligned}
	&succs : Ord \tto Set~\Re \tto Set~\Re \\
	&\lzfcsplit{
		&succs~\alpha~A \ := \ \\
		&\tab\lzfccase{\alpha}{
			0 & A \\
			\beta+1 & A \u (image~(+~1.0)~(succs~\beta~A)) \\
			else & \U\limits_{\beta < \alpha} succs~\beta~A
		}
	}
\end{aligned}
\end{equation}
With this, we can compute the closure as desired:
\begin{equation}
\begin{aligned}
	&succs~\omega~\set{0.5} \ \\
		&\tab = \ (succs~0~\set{0.5}) \u (succs~1~\set{0.5}) \u \cdots \\
		&\tab = \ \set{0.5, 1.5, 2.5, 3.5, ...}
\end{aligned}
\end{equation}
The function terminates because each branch, though unbounded, is finite in length.
As with strict data structures, the shape of the computation is ``infinitely wide'' but not ``infinitely tall.''

The $succs$ function is a special case of a powerful general closure operator defined by
\begin{equation}
\begin{aligned}
	&close : (Set~x \tto Set~x) \tto Ord \tto Set~x \tto Set~x \\
	&close~f~\alpha~A \ := \ 
		\lzfccase{\alpha}{
			0 & A \\
			\beta+1 & A \u (f~(close~f~\beta~A)) \\
			else & \U\limits_{\beta < \alpha} close~f~\beta~A
		}
\end{aligned}
\end{equation}
With this, $succs := close~(image~(+~1.0))$.

The $close$ function can construct the least fixpoint of any monotone set function, if a fixpoint exists.
Such fixpoints include the languages of context-free grammars and the reduction relations defined by inductive rules in operational semantics.
(For almost all of these, only countably many iterations is sufficient.)
We will use $close$ to construct $\sigma$-algebras and preimages, two of the main objects of study in measure theory.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Measure Theory}

XXX: overview, with analogies to topology

\subsection{Sigma-Algebras}

XXX: motivate and define informally

\allowdisplaybreaks

Formally, using the following functions to generate $\emptyset$, complements, and countable unions from families of any type $x$:
\begin{align}
	&\begin{aligned}
		&\sigma@comps : Set~(Set~x) \tto Set~(Set~x) \\
		&\sigma@comps~\A \ := \ \setb{A \w A'}{A, A' \in \A} \\
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		&\sigma@unions : Set~(Set~x) \tto Set~(Set~x) \\
		&\sigma@unions~\A \ := \ \setb{\U\A'}{\A' \subseteq \A \band |\A'| \leq \omega} \\
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		&\sigma@ops : Set~(Set~x) \tto Set~(Set~x) \\
		&\sigma@ops~\A \ := \ \set{\emptyset} \u (\sigma@comps~\A) \u (\sigma@unions~\A) \\
	\end{aligned}
\end{align}
the following function identifies $\sigma$-algebras:
\begin{equation}
\begin{aligned}
	&\sigma@algebra? : Set~(Set~x) \tto Bool \\
	&\sigma@algebra?~\A \ := \ (\sigma@ops~\A) \subseteq \A
\end{aligned}
\end{equation}

Clearly, $\powerset~A$ for any set $A$ is a $\sigma$-algebra.
Unfortunately, this $\sigma$-algebra is ``too large''---a concept we will formalize when discussing measures.
(XXX: cover earlier, in motivation, using Banach-Tarski paradox?)

The \keyword{trace} of a family of subsets $\A$ with a set $A$ is the result of intersecting every $A' \in \A$ with $A$:
\begin{equation}
\begin{aligned}
	&trace : Set~(Set~x) \tto Set~x \tto Set~(Set~x) \\
	&trace~\A~A \ := \ \setb{A \i A'}{A' \in \A} \\
	&\A\restrict{A} \ := \ trace~\A~A
\end{aligned}
\end{equation}

\begin{lemma}[traces of $\sigma$-algebras are $\sigma$-algebras]
For any $\sigma$-algebra $\A$ and set $A$, $trace~\A~A$ is a $\sigma$-algebra on $A \i \U\A$.
\end{lemma}

\begin{lemma}[$\sigma@close$ distributes over $trace$]
For any family of subsets $\A$ and set $A$, $\sigma@close~(trace~\A~A) = trace~(\sigma@close~\A)~A$.
\label{lem:close-distributes-over-trace}
\end{lemma}


\subsection{Measurable Mappings}

XXX: define and characterize measurable mappings

XXX: images of measurable sets under measurable functions are not always measurable; e.g. projections

\subsection{Generated Sigma-Algebras}

Often, $\sigma$-algebras are too complicated to work with directly.
In such cases, we reason about them in terms of \keyword{generating families}: simpler families of sets that, when closed under $\sigma$-algebra operations, are $\sigma$-algebras with nice properties.

To generate $\sigma$-algebras, first note that $\sigma@ops$ is monotone and has an upper bound (the powerset $\sigma$-algebra).
Therefore, $close$ can generate a least fixpoint from it:
\begin{equation}
\begin{aligned}
	&\sigma@close : Set~(Set~x) \tto Set~(Set~x) \\
	&\sigma@close \ := \ close~\sigma@ops~\omega_1
\end{aligned}
\end{equation}
Here, $\omega_1$ is the \keyword{first uncountable ordinal}, or the least ordinal containing every countable ordinal.\footnote{\lzfclang does not decide the continuum hypothesis; i.e. whether $\omega_1 = |\Re|$.}

\begin{lemma}[generated $\sigma$-algebras]
Let $\A$ be a family of sets and $\A' := \sigma@close~\A$.
Then $\A'$ is the smallest $\sigma$-algebra for which $\A \subseteq \A'$.
\label{lem:generated-sigma-algebra}
\end{lemma}

Perhaps the most well-studied generated $\sigma$-algebras are \keyword{Borel $\sigma$-algebras}: those generated from topologies.
For example, if $\tau$ is the standard topology on $\Re$, containing the open intervals and uncountable unions of open intervals, then $\sigma@close~\tau$ is the Borel $\sigma$-algebra for that topology, containing all intervals (open, closed and half-open), and their countable unions and complements.

Other well-studied, generated $\sigma$-algebras are \keyword{product $\sigma$-algebras}: those generated from the rectangles of, or the pairwise products of sets from, other $\sigma$-algebras.
For example, the product $\sigma$-algebra $\A_1 \otimes \A_2$ can be defined by
\begin{align}
	&\begin{aligned}
		&(\boxtimes) : Set~(Set~x) \tto Set~(Set~y) \tto Set~(Set~\pair{x,y}) \\
		&\A_1 \boxtimes \A_2 \ := \ \setb{A_1 \times A_2}{A_1 \in \A_1, A_2 \in \A_2} \\
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		&(\otimes) : Set~(Set~x) \tto Set~(Set~y) \tto Set~(Set~\pair{x,y}) \\
		&\A_1 \otimes \A_2 \ := \ \sigma@close~(\A_1 \boxtimes \A_2) \\
	\end{aligned}
\end{align}
However, the following theorem is usually taken (somewhat less constructively) as the definition of $\A_1 \otimes \A_2$.
\begin{lemma}[projection mappings are product-measurable]
Let $\A := \A_1 \otimes \A_2$ and $A := \U\A$.
Then $\A$ is the smallest $\sigma$-algebra for which $fst\restrict{A}$ is $\A-\A_1$-measurable and $snd\restrict{A}$ is $\A-\A_2$-measurable.
\end{lemma}

\subsection{Measures and Probabilities}

Now that we have defined what sets can be measured, we can define what it means to measure them.

\begin{definition}[Measure]
A mapping $\mu \in \powerset~X \pto [0,\infty)$ is a \keyword{measure} if
\begin{itemize}
	\item $domain~\mu$ is a $\sigma$-algebra on $X$.
	\item $\mu~\emptyset = 0$.
	\item For all $\A' \subseteq \A$ such that $|\A'| \leq \omega$, $\sum\limits_{A \in \A'} (\mu~A) = \mu~(\U \A')$.
\end{itemize}
\end{definition}

XXX: Probabilities of output sets are preimage measures: if $f \in A \pto B$ is $\A-\B$-measurable and $\P \in \A \to [0,1]$, then
\begin{equation}
	\P~(preimage~f~B)
\end{equation}
is the probability of $B$.

XXX: more explanation, and an example
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Bottom Arrow}

XXX: motivation:
\begin{itemize}
	\item derive preimage arrow from something simple and obviously correct
	\item eventually define functions that may diverge using this arrow; use derivation to do the same with the preimage arrow
	\item will be implemented to run programs on domain samples
\end{itemize}

XXX: Figure~\ref{fig:bottom-arrow-defs} defines the bottom arrow...

\begin{figure*}[t]\centering
\begin{align*}
\begin{aligned}[t]
	&\begin{aligned}[t]
		&\arrbot : (X \tto Y) \tto (X \tto Y_\bot) \\
		&\arrbot~f \ := \ f
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}[t]
		&(\compbot) : (X \tto Y_\bot) \tto (Y \tto Z_\bot) \tto (X \tto Z_\bot) \\
		&(f_1~\compbot~f_2)~x \ := \ if~(f_1~x = \bot)~\bot~(f_2~(f_1~x))
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}[t]
		&(\pairbot) : (X \tto {Y_1}_\bot) \tto (X \tto {Y_2}_\bot) \tto (X \tto \pair{Y_1,Y_2}_\bot) \\
		&(f_1~\pairbot~f_2)~x \ := \ if~((f_1~x = \bot) \bor (f_2~x = \bot))~\bot~{\pair{f_1~x,f_2~x}}
	\end{aligned}
\end{aligned}
&\tab\tab\tab
\begin{aligned}[t]
	&\begin{aligned}[t]
		&\ifbot : \lzfcsplit{&(X \tto Bool_\bot) \tto (1 \tto (X \tto Y_\bot)) \tto (1 \tto (X \tto Y_\bot)) \\ &\tto (X \tto Y_\bot) } \\
		&\ifbot~f_1~f_2~f_3~x \ := \
			\lzfccase{f_1~x}{true & f_2~0~x \\ false & f_3~0~x \\ else & \bot}
	\end{aligned}
\end{aligned}
\end{align*}
\hrule
\caption{Bottom arrow definitions.}
\label{fig:bottom-arrow-defs}
\end{figure*}

XXX: the standard Kleisli conversion of the Maybe monad (using a $\bot$ instead of Just and Maybe), simplified; arrow laws therefore hold (XXX: check terminology)

In a nonstrict or simply typed $\lambda$-calculus, $\ifbot$ can be defined using the other combinators and a function $choose : \pair{Bool,\pair{X,X}} \tto X$, whose boolean input determines which of the $\pair{X,X}$ it returns.
However, \lzfclang is call-by-value, so we need an explicitly lazy conditional.
We would have had to define $\ifbot$ in Section~XXX (implementation) anyway, because the preimage arrow's lift returns unimplementable functions.


XXX: point out that $\ifbot$ receives thunks, and remind readers that $1 = \set{0}$

XXX: Figure~\ref{fig:semantic-function}...

XXX: Roughly, first-order application $(\mathit{x~e})$ runs arrow computation $\mathit{x}$ with a fresh stack with $\mathit{e}$ at the head.
The binding form $(let~\mathit{e}_0~\mathit{e_b})$ pushes $\mathit{e}_0$ onto the stack.
Variables are referenced using $(env~\mathit{n})$ with $(env~0)$ referring to the head.

\newcommand{\gen}{_\mathrm{a}}
\newcommand{\genb}{_\mathrm{b}}

\begin{figure*}[t]\centering
\begin{align*}
\begin{aligned}[t]
	\meaningof{\mathit{x} := \mathit{e};\ \cdots}\gen &\ :\equiv\
		\mathit{x} := \meaningof{\mathit{e}}\gen;\ \cdots \\
	\meaningof{\mathit{x}~\mathit{e}}\gen &\ :\equiv\
		\meaningof{\pair{\mathit{e},0}}\gen~\arrowcomp\gen~\mathit{x}
\\
	\meaningof{\pair{\mathit{e}_1,\mathit{e}_2}}\gen &\ :\equiv\
		\meaningof{\mathit{e}_1}\gen~\arrowpair\gen~\meaningof{\mathit{e}_2}\gen
\\
	\meaningof{if~\mathit{e_c}~\mathit{e_t}~\mathit{e_f}}\gen &\ :\equiv\
		if\gen~
			\meaningof{\mathit{e_c}}\gen~
			(\fun{0}{\meaningof{\mathit{e_t}}\gen})~
			(\fun{0}{\meaningof{\mathit{e_f}}\gen})
\\
	\meaningof{let~\mathit{e}_0~\mathit{e_b}}\gen &\ :\equiv\ 
		(\meaningof{\mathit{e}_0}\gen~\arrowpair\gen~(\arrowarr\gen~id))~
			\arrowcomp\gen~
		\meaningof{\mathit{e_b}}\gen
\\
	\meaningof{env~\mathit{n}}\gen &\ :\equiv\ \arrowarr\gen~\fun{\gamma}{\gamma_\mathit{n}}
\\
\end{aligned}
&\tab\tab\tab
\begin{aligned}[t]
	\meaningof{\mathit{v}}\gen &\ :\equiv\ \arrowarr\gen~\fun{\gamma}{\mathit{v}}
\\
	\meaningof{fst~\mathit{e}}\gen &\ :\equiv\
		\meaningof{\mathit{e}}\gen~\arrowcomp\gen~(\arrowarr\gen~fst)
\\
	\meaningof{snd~\mathit{e}}\gen &\ :\equiv\
		\meaningof{\mathit{e}}\gen~\arrowcomp\gen~(\arrowarr\gen~snd)
\\
	\meaningof{\mathit{e}_1 = \mathit{e}_2}\gen &\ :\equiv\
		\meaningof{\pair{\mathit{e}_1,\mathit{e}_2}}\gen~\arrowcomp\gen~(\arrowarr\gen~\fun{\pair{x,y}}{x = y})
\\
	\meaningof{\mathit{e}_1 + \mathit{e}_2}\gen &\ :\equiv\
		\meaningof{\pair{\mathit{e}_1,\mathit{e}_2}}\gen~\arrowcomp\gen~(\arrowarr\gen~\fun{\pair{x,y}}{x+y})
\\
	&\ \cdots\ 
\\
\end{aligned}
\end{align*}
\hrule
\caption{Transformation from a let-calculus with first-order definitions and De-Bruijn-indexed bindings to computations in arrow $\mathrm{a}$.
%The type of a transformed expression is $1 \arrow\gen X$, or an arrow from the empty stack $\gamma = 0$ to a value of type $X$.
}
\label{fig:semantic-function}
\end{figure*}

XXX: example: suppose $x \div y$ diverges when $y = 0$...
\begin{equation}
	div_\bot := \meaningof{if~(snd~(env~0) = 0)~\bot~(fst~(env~0) \div snd~(env~0))}
\end{equation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Deriving the Mapping Arrow}

XXX: intermediate step between the bottom and preimage arrows; will not be implemented (no approximation will be implemented, either); computations are in terms of mappings, on which we can apply theorems from measure theory directly

XXX: the type of mapping arrow computations
\begin{equation}
	X \mapto Y \ ::= \ Set~X \tto (X \pto Y)
\end{equation}
XXX: notice $X \pto Y$, not $X \pto Y_\bot$

XXX: motivate removal of bottom (reasons: won't need to propagate it; its absence will be convenient when computing preimages under functions that may diverge)

Lifting a bottom arrow computation $f : X \tto Y_\bot$ to the mapping arrow requires restricting $f$'s domain to a subset of $X$ for which $f$ does not return $\bot$.
It is helpful to have a standalone function $domain_\bot$ that computes such domains, so we define that first, and $\liftmap$ in terms of $domain_\bot$:
\begin{align}
	&\begin{aligned}
		&domain_\bot : (X \tto Y_\bot) \tto Set~X \tto Set~X \\
		&domain_\bot~f~A \ := \ preimage~f\restrict{A}~((image~f~A) \w \set{\bot})
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		&\liftmap : (X \tto Y_\bot) \tto (X \mapto Y) \\
		&\liftmap~f~A \ := \ \lzfclet{A' & domain_\bot~f~A}{f\restrict{A'}}
	\end{aligned}
\end{align}

XXX: the default equality relation, which for \lzfclang terms is alpha equivalence of reduced terms, will not do; need something more extensional

\begin{definition}[Mapping arrow equivalence]
Two mapping arrow computations $g_1 : X \mapto Y$ and $g_2 : X \mapto Y$ are equivalent, or $g_1 \equiv g_2$, when $g_1~A \equiv g_2~A$ for all $A \subseteq X$.
\end{definition}


\subsection{Distributive Laws}

The clearest way to ensure that mapping arrow computations mean what we think they mean is to derive each combinator in a way that makes $\liftmap$ distribute over bottom arrow computations; i.e. it must be a particular kind of \keyword{homomorphism}.

\begin{definition}[arrow+choice homomorphism]
A function $lift\genb : (x \arrow\gen y) \tto (x \arrow\genb y)$ is an \mykeyword{arrow homomorphism} from arrow $\mathrm{a}$ to arrow $\mathrm{b}$ if the following distributive laws hold for appropriately typed $f$, $f_1$ and $f_2$:
\begin{align}
	&\begin{aligned}
		lift\genb~(\arrowarr\gen~f) \ \equiv \ \arrowarr\genb~f
	\label{eqn:lift-distributes-over-arr}
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		lift\genb~(f_1~\arrowpair\gen~f_2) \ \equiv \ (lift\genb~f_1)~\arrowpair\genb~(lift\genb~f_2)
	\label{eqn:lift-distributes-over-pair}
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		lift\genb~(f_1~\arrowcomp\gen~f_2) \ \equiv \ (lift\genb~f_1)~\arrowcomp\genb~(lift\genb~f_2)
	\label{eqn:lift-distributes-over-comp}
	\end{aligned}
\end{align}
It is additionally an \mykeyword{arrow+choice homomorphism} if
\begin{equation}
\begin{aligned}
	&lift\genb~(\arrowif\gen~f_1~f_2~f_3) \ \equiv \ \\
	&\tab\arrowif\genb~(lift\genb~f_1)~(\fun{0}{lift\genb~(f_2~0)})~(\fun{0}{lift\genb~(f_3~0)})
\label{eqn:lift-distributes-over-if}
\end{aligned}
\end{equation}
holds for appropriately typed $f_1$, $f_2$ and $f_3$.
(In nonstrict languages, the thunks may be dropped.)
\label{def:arrow-homomorphism}
\end{definition}

Clearly $\arrowarr\genb := lift\genb \circ \arrowarr\gen$ meets~\eqref{eqn:lift-distributes-over-arr}, so we define $\arrmap$ as a composition.
The next three subsections derive $\pairmap$, $\compmap$ and $\ifmap$ from their corresponding bottom arrow combinators, in a way that ensures $\liftmap$ is an arrow+choice homomorphism.
Figure~\ref{fig:mapping-arrow-defs} contains the resulting definitions.

\begin{figure*}[t]\centering
\begin{align*}
\begin{aligned}[t]
	&\begin{aligned}[t]
		X \mapto Y \ ::= \ Set~X \tto (X \pto Y)
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}[t]
		&\arrmap : (X \tto Y) \tto (X \mapto Y) \\
		&\arrmap \ := \ \liftmap \circ \arrbot
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}[t]
		&(\compmap) : (X \mapto Y) \tto (Y \mapto Z) \tto (X \mapto Z) \\
		&(g_1~\compmap~g_2)~A \ := \ 
			\lzfclet{
				g_1' & g_1~A \\
				g_2' & g_2~(range~g_1')
			}{g_2' \circ\map g_1'}
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}[t]
		&(\pairmap) : (X \mapto Y_1) \tto (X \mapto Y_2) \tto (X \mapto \pair{Y_1,Y_2}) \\
		&(g_1~\pairmap~g_2)~A \ := \ \pair{g_1~A,g_2~A}\map
	\end{aligned} \\
\end{aligned}
&\tab\tab\tab
\begin{aligned}[t]
	&\begin{aligned}[t]
		&\ifmap : (X \mapto Bool) \tto (1 \tto (X \mapto Y)) \tto (1 \tto (X \mapto Y)) \tto (X \mapto Y) \\
		&\lzfcsplit{
			&\ifmap~g_1~g_2~g_3~A \ := \ \\
			&\tab\lzfclet{
				g_1' & g_1~A \\
				g_2' & lazy\map~(g_2~0)~(preimage~g_1'~\set{true}) \\
				g_3' & lazy\map~(g_3~0)~(preimage~g_1'~\set{false})
			}{g_2' \uplus\map g_3'}
		}
	\end{aligned} \\
\\[-6pt]
\hline
\\[-6pt]
	&\begin{aligned}[t]
		&\liftmap : (X \tto Y_\bot) \tto (X \mapto Y) \\
		&\liftmap~f~A \ := \ \setb{\pair{x,y} \in f\restrict{A}}{y \neq \bot}
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}[t]
		&lazy\map : (X \mapto Y) \tto (X \mapto Y) \\
		&lazy\map~g~A \ := \ if~(A = \emptyset)~\emptyset~(g~A)
	\end{aligned}
\end{aligned}
\end{align*}
\hrule
\caption{Mapping arrow definitions.}
\label{fig:mapping-arrow-defs}
\end{figure*}

\subsection{Case: Pairing}

Starting with the left-hand side of~\eqref{eqn:lift-distributes-over-pair}, we first expand definitions.
For any $f_1 : X \tto Y_\bot$, $f_2 : X \tto Z_\bot$, and $A \subseteq X$,
\begin{align*}
	&\liftmap~(f_1~\pairbot~f_2)~A
%\\
%	&\tab \equiv \ \liftmap~(\fun{x}{if~(f_1~x = \bot \bor f_2~x = \bot)~\bot~{\pair{f_1~x,f_2~x}}})~A
\\
	&\tab \equiv \ 
		\lzfclet{
			f & \fun{x}{if~(f_1~x = \bot \bor f_2~x = \bot)~\bot~{\pair{f_1~x,f_2~x}}} \\
			A' & domain_\bot~f~A
		}{f\restrict{A'}}
\numberthis
\end{align*}
Next, we replace the definition of $A'$ with one that does not depend on $f$, and rewrite in terms of $\liftmap~f_1$ and $\liftmap~f_2$:
\begin{align*}
	&\liftmap~(f_1~\pairbot~f_2)~A
\\
	&\tab \equiv \ 
		\lzfclet{
			A_1 & (domain_\bot~f_1~A) \\
			A_2 & (domain_\bot~f_2~A) \\
			A' & A_1 \i A_2
		}{\fun{x \in A'}{\pair{f_1~x,f_2~x}}}
\\
	&\tab \equiv \ 
		\lzfclet{
			g_1 & \liftmap~f_1~A \\
			g_2 & \liftmap~f_2~A \\
			A' & (domain~g_1) \i (domain~g_2)
		}{\fun{x \in A'}{\pair{g_1~x,g_2~x}}}
\\
	&\tab \equiv \ \pair{\liftmap~f_1~A, \liftmap~f_2~A}\map
\numberthis
\end{align*}
Substituting $g_1$ for $\liftmap~f_1$ and $g_2$ for $\liftmap~f_2$ gives a definition for $(\pairmap)$ (Figure~\ref{fig:mapping-arrow-defs}) for which~\eqref{eqn:lift-distributes-over-pair} holds.

\subsection{Case: Composition}

The derivation of $(\compmap)$ is similar to that of $(\pairmap)$ but a little more involved.

XXX: include it?

\subsection{Case: Conditional}

The derivation of $\ifmap$ needs some care to maintain laziness of conditional branches in the presence of recursion.

We will use as an example the following bottom arrow computation, which returns $true$ when applied to $true$ and diverges on $false$:
\begin{equation}
	halts@on@true_\bot \ := \ \ifbot~id~(\fun{0}{id})~(\fun{0}{halts@on@true_\bot})
\end{equation}
Its corresponding mapping arrow computation should diverge only if applied to a set containing $false$.

Starting with the left-hand-side of~\eqref{eqn:liftmap-distributes-over-ifbot}, we expand definitions, and simplify $f$ by restricting it to a domain for which $f_1~x$ cannot be $\bot$:
\begin{align*}
	&\liftmap~(\ifbot~f_1~f_2~f_3)~A \\
	&\tab \equiv \ 
		\lzfclet{
			f & \fun{x}{\lzfccase{f_1~x}{true & f_2~0~x \\ false & f_3~0~x \\ else & \bot}} \\
			A' & domain_\bot~f~A
		}{f\restrict{A'}} \\
	&\tab \equiv \ 
		\lzfclet{
			A_2 & preimage~f_1\restrict{A}~\set{true} \\
			A_3 & preimage~f_1\restrict{A}~\set{false} \\
			f & \fun{x}{if~(f_1~x)~(f_2~0~x)~(f_3~0~x)} \\
			A' & domain_\bot~f~(A_2 \u A_3)
		}{f\restrict{A'}}
\numberthis
\end{align*}
It is tempting at this point to finish by simply converting bottom arrow computations to the mapping arrow; i.e.
\begin{align*}
	&\liftmap~(\ifbot~f_1~f_2~f_3)~A \\
	&\tab \equiv \ 
		\lzfclet{
			g_1 & \liftmap~f_1~A \\
			A_2 & preimage~g_1~\set{true} \\
			A_3 & preimage~g_1~\set{false} \\
			g_2 & \liftmap~(f_2~0)~A_2 \\
			g_3 & \liftmap~(f_3~0)~A_3 \\
			A' & (domain~g_2) \u (domain~g_3)
		}{\fun{x \in A'}{if~(g_1~x)~(g_2~x)~(g_3~x)}}
\numberthis
\end{align*}
This is close to correct.
Unfortunately, for $halts@on@true_\bot$, computing $g_3 := \liftmap~(f_3~0)~A_3$ always diverges.
Wrapping the branch computations $g_2$ and $g_3$ in thunks will not help because $A'$ is computed from their domains.

Note that the ``true'' branch needs to be taken only if $A_2$ is nonempty; similarly for the ``false'' branch and $A_3$.
Further, applying a mapping arrow computation to $\emptyset$ should always yield the empty mapping $\emptyset$.
We can therefore maintain laziness in conditional branches by applying $\liftmap~(f_2~0)$ and $\liftmap~(f_3~0)$ only to nonempty sets, using
\begin{equation}
\begin{aligned}
	&lazy\map : (X \mapto Y) \tto (X \mapto Y) \\
	&lazy\map~f~A \ := \ if~(A = \emptyset)~\emptyset~(f~A)
\end{aligned}
\end{equation}
In terms of $lazy\map$, we have
\begin{align*}
	&\liftmap~(\ifbot~f_1~f_2~f_3)~A \numberthis
\\
	&\tab \equiv \ 
	\lzfclet{
		g_1 & \liftmap~f_1~A \\
		g_2 & lazy\map~(\liftmap~(f_2~0))~(preimage~g_1~\set{true}) \\
		g_3 & lazy\map~(\liftmap~(f_3~0))~(preimage~g_1~\set{false}) \\
		A' & (domain~g_2) \u (domain~g_3)
	}{\fun{x \in A'}{if~(g_1~x)~(g_2~x)~(g_3~x)}}
\\
	&\tab \equiv \
	\lzfclet{
		g_1 & \liftmap~f_1~A \\
		g_2 & lazy\map~(\liftmap~(f_2~0))~(preimage~g_1~\set{true}) \\
		g_3 & lazy\map~(\liftmap~(f_3~0))~(preimage~g_1~\set{false})
	}{g_2 \uplus\map g_3}
\end{align*}
For $halts@on@true_\bot$, $lazy\map~(\liftmap~(f_3~0))~A_3$ does not diverge when $A_3$ is empty.

Substituting $g_1$ for $\liftmap~f_1$, $g_2~0$ for $\liftmap~(f_2~0)$, and $g_3~0$ for $\liftmap~(f_3~0)$ gives a definition for $\ifmap$ (Figure~\ref{fig:mapping-arrow-defs}) for which~\eqref{eqn:liftmap-distributes-over-ifbot} holds.

\subsection{Theorems}

\begin{theorem}[mapping arrow correctness]
$\liftmap$ is an arrow+choice homomorphism.
\end{theorem}
\begin{proof}
By construction.
\end{proof}

The following are easy consequences of the fact that $\liftmap$ is a homomorphism.

\begin{corollary}
$\arrmap$, $(\pairmap)$ and $(\compmap)$ define an arrow.
With $\ifmap$, they define an arrow+choice.
\end{corollary}

\begin{comment}
\begin{corollary}
Let $f : X \tto Y_\bot$ and $g : X \mapto Y$ its corresponding mapping arrow computation.
For all $A \subseteq X$, $g~A$ diverges if and only if there exists an $x \in A$ for which $f~x$ diverges.
\end{corollary}
\end{comment}

\begin{corollary}
If $\meaningof{\mathit{e}}_\bot : X \tto Y_\bot$, then $lift\map~\meaningof{\mathit{e}}_\bot \equiv \meaningof{\mathit{e}}\map$.
\end{corollary}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Lazy Preimage Mappings}

On a computer, we will not often have the luxury of testing each function input to see whether it belongs in a preimage set.
Even for finite domains, doing so is often intractable.

If we wish to compute with infinite sets in the language implementation, we will need an abstraction that makes it easy to replace computation on points with computation on sets.
Therefore, in the preimage arrow, we will confine computation on points to \mykeyword{lazy preimage mappings}, or just \emph{preimage mappings}, for which application is like applying $preimage$.
The type is
\begin{equation}
	X \prepto Y \ ::= \ \pair{Set~Y, Set~Y \tto Set~X}
\end{equation}
Converting a mapping to a lazy preimage mapping:
\begin{equation}
\begin{aligned}
	&pre : (X \pto Y) \tto (X \prepto Y) \\
	&pre~g \ := \ \lzfclet{Y' & range~g \\ p & \fun{B}{preimage~g~B}}{\pair{Y',p}}
\end{aligned}
\end{equation}
Applying a preimage mapping to any subset of its codomain:
\begin{equation}
\begin{aligned}
	&pre@ap : (X \prepto Y) \tto Set~Y \tto Set~X \\
	&pre@ap~\tpair{Y',p}~B \ := \ p~(B \i Y')
\end{aligned}
\end{equation}
The necessary property here is that using $pre@ap$ to compute preimages is the same as computing them from a mapping using $preimage$.
\begin{theorem}[$pre@ap$ computes preimages]
Let $g \in X \pto Y$. For all $B \subseteq Y$, $pre@ap~(pre~g)~B = preimage~g~B$.
\label{thm:pre-like-preimage}
\end{theorem}
\begin{proof}
\begin{align*}
	pre@ap~(pre~g)~B 
		&\ = \ 
			\lzfclet{
				Y' & range~g \\
				p & \fun{B}{preimage~g~B} \\
			}{p~(B \i Y')}
\\
		&\ = preimage~g~(B \i (range~g))
\\
		&\ = preimage~g~B
\end{align*}
\end{proof}

Figure~\ref{fig:preimage-mapping-defs} defines more operations on preimage mappings, including pairing, composition, and disjoint union operations corresponding to the mapping operations in Figure~\ref{fig:mapping-defs}.
Roughly, the correspondence is that $pre$ distributes over mapping operations to yield preimage mapping operations.
The precise correspondence is the subject of the next three theorems, which will be used to derive the preimage arrow from the mapping arrow.

\begin{figure*}
\begin{align*}
\begin{aligned}[t]
	&\begin{aligned}[t]
		&X \prepto Y ::= \pair{Set~Y, Set~Y \tto Set~X}
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}[t]
		&pre : (X \mapto Y) \tto (X \prepto Y) \\
		&pre~g \ := \ \pair{range~g, \fun{B}{preimage~g~B}}
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}[t]
		&pre@ap : (X \prepto Y) \tto Set~Y \tto Set~X \\
		&pre@ap~\tpair{Y',p}~B \ := \ p~(B \i Y') 
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}[t]
		&pre@range : (X \prepto Y) \tto Set~Y \\
		&pre@range \ := \ fst
	\end{aligned}
\end{aligned}
&\tab\tab\tab
\begin{aligned}[t]
	&\begin{aligned}[t]
		&\pair{\cdot,\cdot}\pre : (X \prepto Y_1) \tto (X \prepto Y_2) \tto (X \prepto Y_1 \times Y_2) \\
		&\tpair{\tpair{Y_1',p_1},\tpair{Y_2',p_2}}\pre \ := \ 
		\lzfclet{
			Y' & Y_1' \times Y_2' \\
			p & \fun{B}{\U\limits_{\pair{y_1,y_2} \in B}(p_1~\set{y_1}) \i (p_2~\set{y_2})} \\
		}{\pair{Y',p}}
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}[t]
		&(\circ\pre) : (Y \prepto Z) \tto (X \prepto Y) \tto (X \prepto Z) \\
		&\tpair{Z',p_2} \circ\pre h_1 \ := \ \tpair{Z', \fun{C}{pre@ap~h_1~(p_2~C)}}
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}[t]
		&(\uplus\pre) : (X \prepto Y) \tto (X \prepto Y) \tto (X \prepto Y) \\
		&\lzfcsplit{
			&h_1 \uplus\pre h_2 \ := \ 
			\lzfclet{
					Y' & (pre@range~h_1) \u (pre@range~h_2) \\
					p & \fun{B}{(pre@ap~h_1~B) \uplus (pre@ap~h_2~B)}
				}{\tpair{Y',p}}
		}
	\end{aligned}
\end{aligned}
\end{align*}
\hrule
\caption{Lazy preimage mappings and operations.}
\label{fig:preimage-mapping-defs}
\end{figure*}

First, we need a new notion of equivalence.

\begin{definition}
Two preimage mappings $h_1 : X \prepto Y$ and $h_2 : X \prepto Y$ are equivalent, or $h_1 \equiv h_2$, when $pre@ap~h_1~B = pre@ap~h_2~B$ for all $B \subseteq Y$.
\end{definition}

XXX: define equivalence in terms of equivalence, check observational equivalence in the proofs (specifically divergence)


\subsection{Preimage Mapping Pairing}

XXX: moar wurds in this section

\begin{lemma}[$preimage$ distributes over $\pair{\cdot,\cdot}\map$ and $(\times)$]
Let $g_1 \in X \pto Y_1$ and $g_2 \in X \pto Y_2$.
For all $B_1 \subseteq Y_1$ and $B_2 \subseteq Y_2$, $preimage~\pair{g_1,g_2}\map~(B_1 \times B_2) = (preimage~g_1~B_1) \i (preimage~g_2~B_2)$.
\label{lem:preimage-under-pairing}
\end{lemma}

\begin{theorem}[$pre$ distributes over $\pair{\cdot,\cdot}\map$]
Let $g_1 \in X \pto Y_1$ and $g_2 \in X \pto Y_2$. Then $pre~\pair{g_1,g_2}\map \equiv \pair{pre~g_1,pre~g_2}\pre$.
\label{thm:preimage-mapping-pairing}
\end{theorem}
\begin{proof}
Let $\pair{Y_1',p_1} := pre~g_1$ and $\pair{Y_2',p_2} := pre~g_2$.
Starting from the right-hand side, for all $B \in Y_1 \times Y_2$,
\begin{align*}
	&pre@ap~\tpair{pre~g_1,pre~g_2}\pre~B 
\\
	&\tab = \ 
		\lzfclet{
			Y' & Y_1' \times Y_2' \\
			p & \fun{B}{\U\limits_{\pair{y_1,y_2} \in B}(p_1~\set{y_1}) \i (p_2~\set{y_2})} \\
		}{p~(B \i Y')}
\\
	&\tab = \ \U\limits_{\pair{y_1,y_2} \in (B \i (Y_1' \times Y_2'))}(p_1~\set{y_1}) \i (p_2~\set{y_2})
\\
	&\tab = \ \U\limits_{\pair{y_1,y_2} \in (B \i (Y_1' \times Y_2'))}(preimage~g_1~\set{y_1}) \i (preimage~g_2~\set{y_2})
\\
	&\tab = \ \U\limits_{y \in B \i (Y_1' \times Y_2')}(preimage~\pair{g_1,g_2}\map~\set{y})
\\
	&\tab = \ preimage~\pair{g_1,g_2}\map~(B \i (Y_1' \times Y_2'))
\\
	&\tab = \ preimage~\pair{g_1,g_2}\map~B
\\
	&\tab = \ pre@ap~(pre~\pair{g_1,g_2}\map)~B
\end{align*}
\end{proof}

\subsection{Preimage Mapping Composition}

XXX: moar wurds in this section

\begin{lemma}[$preimage$ distributes over $(\circ\map)$]
Let $g_1 \in X \pto Y$ and $g_2 \in Y \pto Z$.
For all $C \subseteq Z$, $preimage~(g_2 \circ\map g_1)~C = preimage~g_1~(preimage~g_2~C)$.
\label{lem:preimage-under-composition}
\end{lemma}

\begin{theorem}[$pre$ distributes over $(\circ\map)$]
Let $g_1 \in X \pto Y$ and $g_2 \in Y \pto Z$.
Then $pre~(g_2 \circ\map g_1) \equiv (pre~g_2) \circ\pre (pre~g_1)$.
\label{thm:preimage-mapping-composition}
\end{theorem}
\begin{proof}
Let $\tpair{Z',p_2} := pre~g_2$.
Starting from the right-hand side, for all $C \subseteq Z$,
\begin{align*}
	&pre@ap~((pre~g_2) \circ\pre (pre~g_1))~C
\\
	&\tab = \ 
		\lzfclet{
			h & \fun{C}{pre@ap~(pre~g_1)~(p_2~C)} \\
			}{h~(C \i Z')}
\\
	&\tab = \ pre@ap~(pre~g_1)~(p_2~(C \i Z'))
\\
	&\tab = \ pre@ap~(pre~g_1)~(pre@ap~(pre~g_2)~C)
\\
	&\tab = \ preimage~g_1~(preimage~g_2~C)
\\
	&\tab = \ preimage~(g_2 \circ\map g_1)~C
\\
	&\tab = \ pre@ap~(pre~(g_2 \circ\map g_1))~C
\end{align*}
\end{proof}

\subsection{Preimage Mapping Disjoint Union}

XXX: moar wurds in this section

\begin{lemma}[$preimage$ distributes over $(\uplus\map)$]
Let $g_1 \in X \pto Y$ and $g_2 \in X \pto Y$ be disjoint mappings.
For all $B \subseteq Y$, $preimage~(g_1 \uplus\map g_2)~B = (preimage~g_1~B) \uplus (preimage~g_2~B)$.
\label{lem:preimage-under-piecewise}
\end{lemma}

\begin{theorem}[$pre$ distributes over $(\uplus\map)$]
Let $g_1 \in X \pto Y$ and $g_2 \in X \pto Y$ have disjoint domains.
Then $pre~(g_1 \uplus\map g_2) \equiv (pre~g_1) \uplus\pre (pre~g_2)$.
\label{thm:piecewise-preimage-mappings}
\end{theorem}
\begin{proof}
Let $Y_1' := pre@range~(pre~g_1)$ and $Y_2' := pre@range~(pre~g_2)$.
Starting from the right-hand side, for all $B \subseteq Y$,
\begin{align*}
	&pre@ap~((pre~g_1) \uplus\pre (pre~g_2))~B
\\
	&\tab = \ 
		\lzfclet{
			Y' & Y_1' \u Y_2' \\
			h & \fun{B}{(pre@ap~(pre~g_1)~B) \uplus (pre@ap~(pre~g_2)~B)}
		}{h~(B \i Y')}
\\
	&\tab = \ \lzfcsplit{&(pre@ap~(pre~g_1)~(B \i (Y_1' \u Y_2')))\ \uplus\\ &(pre@ap~(pre~g_2)~(B \i (Y_1' \u Y_2')))}
\\
	&\tab = \ \lzfcsplit{&(preimage~g_1~(B \i (Y_1' \u Y_2')))\ \uplus\\ &(preimage~g_2~(B \i (Y_1' \u Y_2')))}
\\
	&\tab = \ preimage~(g_1 \uplus\map g_2)~(B \i (Y_1' \u Y_2'))
\\
	&\tab = \ preimage~(g_1 \uplus\map g_2)~B
\\
	&\tab = \ pre@ap~(pre~(g_1 \uplus\map g_2))~B
\end{align*}
\end{proof}

\section{Deriving the Preimage Arrow}

XXX: intro

\begin{equation}
	X \preto Y \ ::= \ Set~X \tto (X \prepto Y)
\end{equation}

\begin{equation}
\begin{aligned}
	&\liftpre : (X \mapto Y) \tto (X \preto Y) \\
	&\liftpre~g~A \ := \ pre~(g~A)
\end{aligned}
\end{equation}

\begin{definition}[Preimage arrow equivalence]
Two preimage arrow computations $h_1 : X \preto Y$ and $h_2 : X \preto Y$ are equivalent, or $h_1 \equiv h_2$, when 
$h_1~A \equiv h_2~A$ for all $A \subseteq X$.
\end{definition}

\subsection{Distributive Laws}

XXX: ensuring $\liftpre$ distributes over mapping arrow computations is awesome...

Formally, we require the following distributive laws to hold:
\begin{align}
	&\begin{aligned}
		\liftpre~(\arrmap~f) \ \equiv \ \arrpre~f
	\label{eqn:liftpre-distributes-over-arrmap}
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		\liftpre~(g_1~\pairmap~g_2) \ \equiv \ (\liftpre~g_1)~\pairpre~(\liftpre~g_2)
	\label{eqn:liftpre-distributes-over-pairmap}
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		\liftpre~(g_1~\compmap~g_2) \ \equiv \ (\liftpre~g_1)~\comppre~(\liftpre~g_2)
	\label{eqn:liftpre-distributes-over-compmap}
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		&\liftpre~(\ifmap~g_1~g_2~g_3) \ \equiv \ \\
		&\tab\ifpre~(\liftpre~g_1)~(\fun{0}{\liftpre~(g_2~0)})~(\fun{0}{\liftpre~(g_3~0)})
	\label{eqn:liftpre-distributes-over-ifmap}
	\end{aligned}
\end{align}
Clearly $\arrpre~f := \liftpre~(\arrmap~f)$ meets~\eqref{eqn:liftpre-distributes-over-arrmap}.
Figure~\ref{fig:preimage-arrow-defs} shows the result of deriving the other combinators from the mapping arrow using distributive laws.

\begin{figure*}
\begin{align*}
\begin{aligned}[t]
	&\begin{aligned}[t]
		&X \preto Y ::= Set~X \tto (X \prepto Y)
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}[t]
		&\arrpre : (X \mapto Y) \tto (X \preto Y) \\
		&\arrpre~g~A \ := \ pre~(g~A)
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}[t]
		&(\comppre) : (X \preto Y) \tto (Y \preto Z) \tto (X \preto Z) \\
		&(h_1~\comppre~h_2)~A \ := \ 
			\lzfclet{
				h_1' & h_1~A \\
				h_2' & h_2~(pre@range~h_1')
			}{h_2 \circ\pre h_1}
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}[t]
		&(\pairpre) : (X \preto Y) \tto (X \preto Z) \tto (X \preto Y \times Z) \\
		&(h_1~\pairpre~h_2)~A \ := \ \pair{h_1~A,h_2~A}\pre
	\end{aligned}
\end{aligned}
&\tab\tab\tab
\begin{aligned}[t]
	&\begin{aligned}[t]
		&\ifpre: (X \preto Bool) \tto (1 \tto (X \preto Y)) \tto (1 \tto (X \preto Y)) \tto (X \preto Y) \\
		&\lzfcsplit{
			&\ifpre~h_1~h_2~h_3~A \ := \ \\
			&\lzfclet{
				h_1' & h_1~A \\
				h_2' & lazy\pre~(h_2~0)~(pre@ap~h_1'~\set{true}) \\
				h_3' & lazy\pre~(h_3~0)~(pre@ap~h_1'~\set{false})
			}{h_2' \uplus\pre h_3'}
		}
	\end{aligned} \\
\\
\\[-6pt]
	&\begin{aligned}[t]
		&lazy\pre : (X \preto Y) \tto (X \preto Y) \\
		&lazy\pre~h~A \ := \ if~(A = \emptyset)~(pre~\emptyset)~(h~A)
	\end{aligned}
\end{aligned}
\end{align*}
\hrule
\caption{Preimage arrow definitions.}
\label{fig:preimage-arrow-defs}
\end{figure*}

\begin{theorem}[preimage arrow correctness]
$\liftpre$ distributes over mapping arrow computations.
\end{theorem}
\begin{proof}
By structural induction; cases follow.
\end{proof}

\subsection{Case: Pairing}

Starting with the left-hand side of~\eqref{eqn:liftpre-distributes-over-pairmap}, we expand definitions, apply Theorem~\ref{thm:preimage-mapping-pairing}, and rewrite in terms of $\liftpre$:
\begin{align*}
	&pre@ap~(\liftpre~(g_1~\pairmap~g_2)~A)~B
\\
	&\tab \equiv \ pre@ap~(pre~\pair{g_1~A, g_2~A}\map)~B
\\
	&\tab \equiv \ pre@ap~\pair{pre~(g_1~A), pre~(g_2~A)}\pre~B
\\
	&\tab \equiv \ pre@ap~\pair{\liftpre~g_1~A, \liftpre~g_2~A}\pre~B
\end{align*}
Substituting $h_1$ for $\liftpre~g_1$ and $h_2$ for $\liftpre~g_2$, and removing the application of $pre@ap$ from both sides of the equivalence gives a definition of $(\pairpre)$ (Figure~\ref{fig:preimage-arrow-defs}) for which~\eqref{eqn:liftpre-distributes-over-pairmap} holds.

\subsection{Case: Composition}

Starting with the left-hand side of~\eqref{eqn:liftpre-distributes-over-compmap}, we expand definitions, apply Theorem~\ref{thm:preimage-mapping-composition} and rewrite in terms of $\liftpre$:
\begin{align*}
	&pre@ap~(\liftpre~(g_1~\compmap~g_2)~A)~C
\\
	&\tab \equiv \ 
		\lzfclet{
			g_1' & g_1~A \\
			g_2' & g_2~(range~g_1')
		}{pre@ap~(pre~(g_2' \circ\map g_1'))~C}
\\
	&\tab \equiv \ 
		\lzfclet{
			g_1' & g_1~A \\
			g_2' & g_2~(range~g_1')
		}{pre@ap~((pre~g_1') \circ\pre (pre~g_2'))~C}
\\
	&\tab \equiv \
		\lzfclet{
			h_1 & \liftpre~g_1~A \\
			h_2 & \liftpre~g_2~(pre@range~h_1)
		}{pre@ap~(h_2 \circ\pre h_1)~C}
\numberthis
\end{align*}
Substituting $h_1$ for $\liftpre~g_1$ and $h_2$ for $\liftpre~g_2$, and removing the application of $pre@ap$ from both sides of the equivalence gives a definition of $(\comppre)$ (Figure~\ref{fig:preimage-arrow-defs}) for which~\eqref{eqn:liftpre-distributes-over-compmap} holds.

\subsection{Case: Conditional}

Starting with the left-hand side of~\eqref{eqn:liftpre-distributes-over-ifmap}, we expand terms, apply Theorem~\ref{thm:piecewise-preimage-mappings}, rewrite in terms of $\liftpre$, and apply Theorem~\ref{thm:pre-like-preimage} in the definitions of $h_2$ and $h_3$:
\begin{align*}
	&pre@ap~(\liftpre~(\ifmap~g_1~g_2~g_3)~A)~B
\\
	&\tab \equiv \ 
		\lzfclet{
			g_1' & g_1~A \\
			g_2' & lazy\map~(g_2~0)~(preimage~g_1'~\set{true}) \\
			g_3' & lazy\map~(g_3~0)~(preimage~g_1'~\set{false})
		}{pre@ap~(pre~(g_2' \uplus\map g_3'))~B}
\\
	&\tab \equiv \ 
		\lzfclet{
			g_1' & g_1~A \\
			g_2' & lazy\map~(g_2~0)~(preimage~g_1'~\set{true}) \\
			g_3' & lazy\map~(g_3~0)~(preimage~g_1'~\set{false})
		}{pre@ap~((pre~g_2') \uplus\pre (pre~g_3'))~B}
\\
	&\tab \equiv \ 
		\lzfclet{
			g_1' & g_1~A \\
			h_2 & \liftpre~(lazy\map~(g_2~0))~(preimage~g_1'~\set{true}) \\
			h_3 & \liftpre~(lazy\map~(g_3~0))~(preimage~g_1'~\set{false})
		}{pre@ap~(h_2 \uplus\pre h_3)~B}
\\
	&\tab \equiv \ 
		\lzfclet{
			h_1 & \liftpre~g_1~A \\
			h_2 & \liftpre~(lazy\map~(g_2~0))~(pre@ap~h_1~\set{true}) \\
			h_3 & \liftpre~(lazy\map~(g_3~0))~(pre@ap~h_1~\set{false})
		}{pre@ap~(h_2 \uplus\pre h_3)~B}
\end{align*}
Replacing mappings with lazy preimage mappings requires removing $lazy\map$.
First, we define $lazy\pre$ as in Figure~\ref{fig:preimage-arrow-defs}.
It is not hard to check that
\begin{equation}
	\liftpre~(lazy\map~g) \ \equiv \ lazy\pre~(\liftpre~g)
\label{eqn:arrpre-distributes-over-lazymap}
\end{equation}
In terms of $lazy\pre$, we have
\begin{align*}
	&pre@ap~(\liftpre~(\ifmap~g_1~g_2~g_3)~A)~B
\\
	&\tab \equiv \ 
		\lzfclet{
			h_1 & \liftpre~g_1~A \\
			h_2 & lazy\pre~(\liftpre~(g_2~0))~(pre@ap~h_1~\set{true}) \\
			h_3 & lazy\pre~(\liftpre~(g_3~0))~(pre@ap~h_1~\set{false})
		}{pre@ap~(h_2 \uplus\pre h_3)~B}
\end{align*}
Substituting $h_1$ for $\liftpre~g_1$, $h_2~0$ for $\liftpre~(g_2~0)$ and $h_3~0$ for $\liftpre~(g_3~0)$, and removing the application of $pre@ap$ from both sides of the equivalence gives a definition of $\ifpre$ (Figure~\ref{fig:preimage-arrow-defs}) for which~\eqref{eqn:liftpre-distributes-over-ifmap} holds.

\subsection{Super-Saver Theorems}

The following theorems are easy consequences of the fact that $\liftpre$ distributes over mapping arrow computations.

\begin{corollary}
$\arrpre$, $(\pairpre)$ and $(\comppre)$ define an arrow.
\end{corollary}

\begin{comment}
\begin{corollary}
Let $g : X \mapto Y$ and $h : X \preto Y$ its corresponding preimage arrow computation.
For all $A \subseteq X$ and $B \subseteq Y$, $pre@ap~(h~A)~B \equiv preimage~(g~A)~B$.
\end{corollary}
\end{comment}

\begin{corollary}
If $\meaningof{e}\map : X \mapto Y$, then for all $A \subseteq X$ and $B \subseteq Y$, $preimage~(\meaningof{e}\map~A)~B \equiv pre@ap~(\meaningof{e}\pre~A)~B$.
\end{corollary}

\section{Computable Approximation}


\section{Preimages of Partial Functions}



%\appendix
%\section{Appendix Title}
%This is the text of the appendix, if you need one.

%\acks
%Acknowledgments, if needed.

\bibliographystyle{abbrvnat}
\bibliography{plt}

\end{document}
