%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\input{local-macros.tex}

\newcommand{\restrict}[1]{\lvert_{#1}}
\newcommand{\pto}{\rightharpoonup}
\newcommand{\Univ}{\mathbb{U}}
\newcommand{\Un}{\mathcal{U}}

\newcommand{\arrowarr}{\tlzfc{arr}}
\newcommand{\arrowcomp}{\tlzfc{{>}\mspace{-6mu}{>}\mspace{-6mu}{>}}}
%\newcommand{\arrowpair}{\tlzfc{\&\mspace{-5mu}\&\mspace{-5mu}\&}}
\newcommand{\arrowpair}{\tlzfc{pair}}
\newcommand{\arrowif}{\tlzfc{if}}
\newcommand{\arrowlazy}{\tlzfc{lazy}}
\newcommand{\arrowapp}{\tlzfc{app}}
\newcommand{\arrowrun}{\tlzfc{run}}

\newcommand{\arrbot}{\arrowarr_\bot}
\newcommand{\compbot}{\arrowcomp_\bot}
\newcommand{\pairbot}{\arrowpair_\bot}
\newcommand{\ifbot}{\arrowif_\bot}

\newcommand{\map}{_\mathrm{map}}
\DeclareMathOperator{\mapto}{\rightsquigarrow_{\mspace{-21mu}\map}}
\DeclareMathOperator{\eqmap}{\mbox{\tlzfc{=_{\mspace{-19mu}\map}}}}
\newcommand{\arrmap}{\arrowarr\map}
\newcommand{\compmap}{\arrowcomp\map}
\newcommand{\pairmap}{\arrowpair\map}
\newcommand{\ifmap}{\arrowif\map}

\newcommand{\pre}{_\mathrm{pre}}
\DeclareMathOperator{\preto}{\rightsquigarrow_{\mspace{-19mu}\pre}}
\DeclareMathOperator{\eqpre}{=_{\mspace{-17mu}\pre}}
\newcommand{\arrpre}{\arrowarr\pre}
\newcommand{\comppre}{\arrowcomp\pre}
\newcommand{\pairpre}{\arrowpair\pre}
\newcommand{\ifpre}{\arrowif\pre}

\newcommand{\prepto}{\pto_{\mspace{-19mu}\pre}}


\begin{document}

\conferenceinfo{POPL '14}{January 22-24, 2014, San Diego, CA, USA}
\copyrightyear{2014}
\copyrightdata{[to be supplied]} 

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Running Probabilistic Programs Backwards}
%\subtitle{Subtitle Text, if any}

\authorinfo{Neil Toronto \and Jay McCarthy}
           {PLT @ Brigham Young University}
           {ntoronto@racket-lang.org \and jay@byu.edu}
\authorinfo{Chris Grant}
           {Brigham Young University}
           {grant@math.byu.edu}
\maketitle

\begin{abstract}
XXX
\end{abstract}

\category{XXX-CR-number}{XXX-subcategory}{XXX-third-level}

\terms
XXX, XXX

\keywords
XXX, XXX

\section{Introduction}

XXX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Mathematics and Metalanguage}

From here on, significant terms are introduced in \keyword{bold}, and significant terms we invent are introduced in \mykeyword{bold italics}.

We write all of the mathematics in this paper in \lzfclang~\cite{cit:toronto-2012flops-lzfc}, an untyped, call-by-value lambda calculus designed for manually deriving computable programs from contemporary mathematics.

Contemporary mathematics is generally done in \keyword{ZFC}: \keyword{Zermelo-Fraenkel} set theory extended with the axiom of \keyword{Choice} (equivalently \keyword{Cardinality}).
ZFC has only first-order functions and no general recursion, which makes implementing a language defined by a transformation into contemporary mathematics quite difficult.
The problem is exacerbated if implementing the language requires approximation.
Targeting \lzfclang instead allows creating a precise mathematical specification and deriving an approximating implementation without changing languages.

In \lzfclang, essentially every set is a value, as well as every lambda and every set of lambdas.
All operations, including operations on infinite sets, are assumed to complete instantly if they terminate.\footnote{An
example of a nonterminating \lzfclang function is one that attempts to decide whether other \lzfclang programs halt.}

Almost everything definable in contemporary mathematics can be formally defined by a finite \lzfclang program, except objects that most mathematicians would agree are nonconstructive.
More precisely, any object that \emph{must} be defined by a statement of existence and uniqueness without giving a bounding set is not definable by a \emph{finite} \lzfclang program.

Because \lzfclang includes an inner model of ZFC, essentially every contemporary theorem applies to \lzfclang programs without alteration.
Further, proofs about \lzfclang objects apply to contemporary mathematical objects.\footnote{Assuming the existence of a single inaccessible cardinal.}

In \lzfclang, algebraic data structures are encoded as sets; e.g. a \mykeyword{primitive ordered pair} of $x$ and $y$ is $\set{\set{x},\set{x,y}}$.
Only the \emph{existence} of encodings into sets is important, as it means data structures inherit a defining characteristic of sets: strictness.
More precisely, the lengths of paths to data structure leaves is unbounded, but each path must be finite.
Less precisely, data may be ``infinitely wide'' (such as $\Re$) but not ``infinitely tall'' (such as infinite lists).

We assume data structures, including pairs, are encoded as \emph{primitive} ordered pairs with the first element a unique tag, so that they can be distinguished by checking tags.
Accessors such as \tlzfc{fst} and \tlzfc{snd} are trivial to define.

\lzfclang is untyped so its users can define an auxiliary type system that best suits their application area.
For this work, we use an informal, manually checked, polymorphic type system characterized by these rules:
\begin{itemize}
	\item A free lowercase type variable is universally quantified.
	\item A free uppercase type variable is a set.
	\item A set denotes a member of that set.
	\item \tlzfc{x \tto y} denotes a partial function.
	\item \tlzfc{\pair{x,y}} denotes a pair of values with types \tlzfc{x} and \tlzfc{y}.
	\item \tlzfc{Set~x} denotes a set with members of type \tlzfc{x}.
\end{itemize}
The type \tlzfc{Set~A} denotes the same values as the powerset \tlzfc{\powerset~A}, and is the type of \emph{subsets} of \tlzfc{A}.
Similarly, the type \tlzfc{\pair{A,B}} is equivalent to the product set \tlzfc{A \times B}.

Most \lzfclang programs are infinite.
We write finite programs in heavily sugared $\lambda$-calculus syntax, with these additional primitives:
\begin{equation}
\lzfcsplit{
	\lzfcsplit{
		\emptyset &: Set~x \\
		\omega &: Ord \\
		card &: Set~x \tto Ord \\
		take &: Set~x \tto x \\
	}
	&\tab
	\lzfcsplit{
		\in &: x \tto Set~x \tto Bool \\
		\powerset &: Set~x \tto Set~(Set~x) \\
		\U &: Set~(Set~x) \tto Set~x \\
		image &: (x \tto y) \tto Set~x \tto Set~y \\
	}
}
\end{equation}
Shortly, \tlzfc{\emptyset} is the empty set, \tlzfc{\omega} is the cardinality of the natural numbers, \tlzfc{card} returns the cardinality of a set, \tlzfc{take} removes the member from a singleton set, \tlzfc{\in} is an infix operator that decides membership, \tlzfc{\powerset} returns all the subsets of a set, \tlzfc{\U} returns the union of a set of sets, and \tlzfc{image} applies a function to each member of a set and returns the set of results.
%Each primitive is derived from a ZFC axiom.

\subsection{Additional Functions and Forms}

XXX: syntactic sugar: automatic currying, matching, sectioning rules, set comprehensions, cardinality, indexed unions

XXX: \tlzfc{A \pto B} is the set of partial mappings...

XXX: put Englishy word thingies around the following so it's not just a wall of meaningless code:

\begin{equation}
\lzfcsplit{
	&restrict : (A \tto B) \tto \powerset~A \tto (A \pto B) \\
	&restrict~f~A' \ := \ image~(\fun{x}{(x, f~x)})~A'
}
\end{equation}

\begin{equation}
\lzfcsplit{
	&f\restrict{A} \ :\equiv \ restrict~f~A \\
	&\fun{x \in A}{e} \ :\equiv \ (\fun{x}{e})\restrict{A}
}
\end{equation}

\begin{equation}
\lzfcsplit{
	&domain : (A \pto B) \tto Set~A \\
	&domain~f \ := \ image~fst~f
}
\end{equation}

\begin{equation}
\lzfcsplit{
	&range : (A \pto B) \tto Set~B \\
	&range~f \ := \ image~snd~f
}
\end{equation}

\begin{equation}
\lzfcsplit{
	&preimage : (A \pto B) \tto Set~B \tto Set~A \\
	&preimage~f~B \ :=\ \setb{x \in domain~f}{f~x \in B}
}
\end{equation}

\begin{equation}
\lzfcsplit{
	&(\circ\map) : (Y \pto Z) \tto (X \pto Y) \tto (X \pto Z) \\
	&g_2 \circ\map g_1 \ := \ 
		\ilzfclet{
			A & preimage~g_1~(domain~g_2)
		}{\fun{x \in A}{g_2~(g_1~x)}}
}
\end{equation}

\begin{equation}
\lzfcsplit{
	&\pair{\cdot,\cdot}\map : (X \pto Y) \tto (X \pto Z) \tto (X \pto Y \times Z) \\
	&\pair{g_1,g_2}\map \ := \ 
		\ilzfclet{
			A & (domain~g_1) \i (domain~g_2)
		}{\fun{x \in A}{\pair{g_1~x,g_2~x}}}
}
\end{equation}

\subsection{Ordinal Numbers and Transfinite Recursion}

The \keyword{ordinal numbers}, or values of type \tlzfc{Ord}, are an extension of the natural numbers to infinite lengths.
Ordinals are typically defined as the smallest sets that contain all their predecessors; e.g. the first four are
\begin{equation}
\lzfcsplit{
	\lzfcsplit{
		0 &\ := \ \emptyset \\
		1 &\ := \ \set{0}
	}
	&\tab\tab
	\lzfcsplit{
		2 &\ := \ \set{0,1} \\
		3 &\ := \ \set{0,1,2}
	}
}
\end{equation}
The smallest infinite ordinal \tlzfc{\omega} is the set of all finite ordinals.
Other infinite ordinals are defined in terms of \tlzfc{\omega}:
\begin{equation}
\lzfcsplit{
	\omega &\ := \ \set{0,1,2,3,...} \\
	\omega+1 &\ := \ \set{0,1,2,3,...,\omega} \\
	\omega+2 &\ := \ \set{0,1,2,3,...,\omega,\omega+1} \\
	\omega+\omega &\ := \ \set{0,1,2,3,...,\omega,\omega+1,\omega+2,...}
}
\end{equation}
The above sets are all countable, meaning that their cardinality is \tlzfc{\omega}.
Generally, any ordinal \tlzfc{\alpha} for which \tlzfc{\alpha = |\alpha|} is also called a \keyword{cardinal number}.%\footnote{Think of ordinals as lengths of ordered collections, and cardinals as sizes of unordered collections.}

Ordinals are totally ordered by membership; i.e. \tlzfc{\beta < \alpha} is equivalent to \tlzfc{\beta \in \alpha}.
Ordinals with an immediate predecessor (such as \tlzfc{3} and \tlzfc{\omega+2}) are called \keyword{successor ordinals}.
Nonzero ordinals without an immediate predecessor (roughly, those whose literal representations end in ``\tlzfc{...}'') are called \keyword{limit ordinals}.

Limit ordinals allow writing terminating functions that recur infinitely many times.
Suppose we wanted a function that recursively generates all the integral successors of \tlzfc{0.5}.
Consider this first attempt, which can be written in any Turing-equivalent language:
\begin{equation}
\lzfcsplit{
	&succs : \omega \tto Set~\Re \tto Set~\Re \\
	&succs~n~A \ := \ \\
	&\tab\ilzfccase{n}{
		0 & A \\
		m+1 & A \u (image~(+~1.0)~(succs~m~A))
	}
}
\end{equation}
This unfold over finite ordinals generates prefixes such as
\begin{equation}
\lzfcsplit{
	succs~0~\set{0.5} \ &= \ \set{0.5} \\
	succs~1~\set{0.5} \ &= \ \set{0.5, 1.5} \\
	succs~2~\set{0.5} \ &= \ \set{0.5, 1.5, 2.5}
}
\end{equation}
but will never generate the full set of integral successors.

To close \tlzfc{\set{0.5}} under increment, we can use \keyword{transfinite recursion}: unfolding over ordinals as above, but using an additional inductive case for limit ordinals:
\begin{equation}
\lzfcsplit{
	&succs : Ord \tto Set~\Re \tto Set~\Re \\
	&succs~\alpha~A \ := \ \\
	&\tab\ilzfccase{\alpha}{
		0 & A \\
		\beta+1 & A \u (image~(+~1.0)~(succs~\beta~A)) \\
		else & \U_{\beta < \alpha}~succs~\beta~A
	}
}
\end{equation}
With this, we can compute the closure as desired:
\begin{equation}
\lzfcsplit{
	succs~\omega~\set{0.5} \ 
		&= \ (succs~0~\set{0.5}) \u (succs~1~\set{0.5}) \u \cdots \\
		&= \ \set{0.5, 1.5, 2.5, 3.5, ...}
}
\end{equation}
The function terminates because each branch, though unbounded, is finite in length.
As with strict data structures, the shape of the computation is ``infinitely wide'' but not ``infinitely tall.''

The \tlzfc{succs} function is a special case of a powerful general closure operator defined by
\begin{equation}
\lzfcsplit{
	&close : (Set~x \tto Set~x) \tto Ord \tto Set~x \tto Set~x \\
	&close~f~\alpha~A \ := \ \\
	&\tab\ilzfccase{\alpha}{
		0 & A \\
		\beta+1 & A \u (f~(close~f~\beta~A)) \\
		else & \U_{\beta < \alpha}~close~f~\beta~A}
}
\end{equation}
With this, \tlzfc{succs = close~(image~(+~1.0))}.

The \tlzfc{close} function can construct the least fixpoint of any monotone set function, if a fixpoint exists.
Such fixpoints include the languages of context-free grammars and the reduction relations defined by inductive rules in operational semantics.
(For almost all of these, only countably many iterations is sufficient.)
We will use \tlzfc{close} to construct $\sigma$-algebras and preimages, two of the main objects of study in measure theory.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Measure Theory}

XXX: overview, with analogies to topology

\subsection{Sigma-Algebras}

XXX: motivate and define informally

Formally, using the following functions to generate \tlzfc{\emptyset}, complements, and countable unions from families of any type \tlzfc{x}:
\begin{equation}
\lzfcsplit{
	&\sigma@comps : Set~(Set~x) \tto Set~(Set~x) \\
	&\sigma@comps~\A \ := \ \setb{A \w A'}{A, A' \in \A} \\
\\
	&\sigma@unions : Set~(Set~x) \tto Set~(Set~x) \\
	&\sigma@unions~\A \ := \ \setb{\U\A'}{\A' \subseteq \A \band |\A'| \leq \omega} \\
\\
	&\sigma@ops : Set~(Set~x) \tto Set~(Set~x) \\
	&\sigma@ops~\A \ := \ \set{\emptyset} \u (\sigma@comps~\A) \u (\sigma@unions~\A)
}
\end{equation}
the following function identifies $\sigma$-algebras:
\begin{equation}
\lzfcsplit{
	&\sigma@algebra? : Set~(Set~x) \tto Bool \\
	&\sigma@algebra?~\A \ := \ (\sigma@ops~\A) \subseteq \A
}
\end{equation}

Clearly, \tlzfc{\powerset~A} for any set \tlzfc{A} is a $\sigma$-algebra.
Unfortunately, this $\sigma$-algebra is ``too large''---a concept we will formalize when discussing measures.
(XXX: cover earlier, in motivation, using Banach-Tarski paradox?)

The \keyword{trace} of a $\sigma$-algebra $\A$ with a set \tlzfc{A} is the result of intersecting every \tlzfc{A' \in \A} with \tlzfc{A}:
\begin{equation}
\lzfcsplit{
	&\sigma@trace : Set~(Set~x) \tto Set~x \tto Set~(Set~x) \\
	&\sigma@trace~\A~A \ := \ \setb{A \i A'}{A' \in \A}
}
\end{equation}
There are no restrictions on \tlzfc{A}.
In particular, it does not have to be in \tlzfc{\A} (i.e. measurable).

\begin{lemma}[Traces of $\sigma$-algebras are $\sigma$-algebras]
Let \tlzfc{\A} be a $\sigma$-algebra and \tlzfc{A} any set.
Then \tlzfc{\sigma@trace~\A~A} is a $\sigma$-algebra on \tlzfc{A \i \U\A}.
\end{lemma}

\subsection{Measurable Mappings}

XXX: define and characterize measurable mappings

XXX: images of measurable sets under measurable functions are not always measurable; e.g. projections

\subsection{Generated Sigma-Algebras}

Often, $\sigma$-algebras are too complicated to work with directly.
In such cases, we reason about them in terms of \keyword{generating families}: simpler families of sets that, when closed under $\sigma$-algebra operations, are $\sigma$-algebras with nice properties.

To generate $\sigma$-algebras, first note that \tlzfc{\sigma@ops} is monotone and has an upper bound (the powerset $\sigma$-algebra).
Therefore, \tlzfc{close} can generate a least fixpoint from it:
\begin{equation}
\lzfcsplit{
	&\sigma@close : Set~(Set~x) \tto Set~(Set~x) \\
	&\sigma@close \ := \ close~\sigma@ops~\omega_1
}
\end{equation}
Here, \tlzfc{\omega_1} is the \keyword{first uncountable ordinal}, or the least ordinal containing every countable ordinal.\footnote{\lzfclang does not decide the continuum hypothesis; i.e. whether \tlzfc{\omega_1 = |\Re|}.}

\begin{lemma}[Generated $\sigma$-algebras]
Let \tlzfc{\A} be a family of sets and \tlzfc{\A' := \sigma@close~\A}.
Then \tlzfc{\A'} is the smallest $\sigma$-algebra for which \tlzfc{\A \subseteq \A'}.
\label{lem:generated-sigma-algebra}
\end{lemma}

The most well-studied generated $\sigma$-algebras are \keyword{Borel $\sigma$-algebras}: those generated from topologies.
For example, if $\tau_\Re$ is the standard topology on $\Re$, containing the open intervals and uncountable unions of open intervals, then
\begin{equation}
\lzfc{\sigma~\Re \ = \ \sigma@close~\tau_\Re}
\end{equation}
is the Borel $\sigma$-algebra for that topology, containing all intervals (open, closed and half-open), and their countable unions and complements.
(We will formally define the \tlzfc{\sigma} function further on.)
We call this the \mykeyword{standard $\sigma$-algebra} for $\Re$.

Other well-studied, generated $\sigma$-algebras are \keyword{product $\sigma$-algebras}: those generated from the rectangles of, or the pairwise products of sets from, other $\sigma$-algebras.
For example, the product $\sigma$-algebra $\A_1 \otimes \A_2$ can be defined by
\begin{equation}
\lzfcsplit{
	&(\boxtimes) : Set~(Set~x) \tto Set~(Set~y) \tto Set~(Set~\pair{x,y}) \\
	&\A_1 \boxtimes \A_2 \ := \ \setb{A_1 \times A_2}{A_1 \in \A_1, A_2 \in \A_2}\\
\\
	&(\otimes) : Set~(Set~x) \tto Set~(Set~y) \tto Set~(Set~\pair{x,y}) \\
	&\A_1 \otimes \A_2 \ := \ \sigma@close~(\A_1 \boxtimes \A_2)
}
\end{equation}
A product $\sigma$-algebra is the smallest $\sigma$-algebra for which pair projections (\tlzfc{fst} and \tlzfc{snd}) are measurable.

\begin{lemma}[Projection mappings are product-measurable]
Let \tlzfc{\A} \tlzfc{:=} \tlzfc{\A_1 \otimes \A_2} and \tlzfc{A} \tlzfc{:=} \tlzfc{\U\A}.
Then \tlzfc{\A} is the smallest $\sigma$-algebra for which \tlzfc{fst\restrict{A}} is \tlzfc{\A-\A_1} measurable and \tlzfc{snd\restrict{A}} is \tlzfc{\A-\A_2} measurable.
\end{lemma}

\subsection{Measures and Probability}

The mapping \tlzfc{\mu \in \powerset~X \pto [0,\infty)} is a \keyword{measure} if
\begin{itemize}
	\item \tlzfc{domain~\mu} is a $\sigma$-algebra.
	\item \tlzfc{\mu~\emptyset = 0}.
	\item For all \tlzfc{\A' \subseteq \A} countable, \tlzfc{\sum\limits_{A \in \A'} (\mu~A)} \tlzfc{=} \tlzfc{\mu~(\U \A')}.
\end{itemize}

XXX: Probabilities of output sets are preimage measures: if \tlzfc{f \in A \pto B} is $\A-\B$ measurable and \tlzfc{\P \in \A \to [0,1]}, then
\begin{equation}
\lzfcsplit{
	\P~(preimage~f~B)
}
\end{equation}
is the probability of \tlzfc{B}.

XXX: more explanation, and an example

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Bottom Arrow}

XXX: motivation:
\begin{itemize}
	\item derive preimage arrow from something simple and obviously correct
	\item eventually define functions that may diverge using this arrow; use derivation to do the same with the preimage arrow
	\item will be implemented to run programs on domain samples
\end{itemize}

XXX: Fig.~\ref{fig:bottom-arrow-defs} defines the bottom arrow...

\begin{figure*}[t]\centering
\begin{varwidth}{\textwidth}
\begin{equation*}
\lzfcsplit{
	&\arrbot : (X \tto Y_\bot) \tto (X \tto Y_\bot) \\
	&\arrbot~f \ := \ f \\
\\
	&\compbot : (X \tto Y_\bot) \tto (Y \tto Z_\bot) \tto (X \tto Z_\bot) \\
	&\compbot~f_1~f_2~x \ := \ if~(f_1~x = \bot)~\bot~(f_2~(f_1~x)) \\
\\
	&\pairbot : (X \tto Y_\bot) \tto (X \tto Z_\bot) \tto (X \tto \pair{Y,Z}_\bot) \\
	&\pairbot~f_2~f_2~x \ := \ if~(f_1~x = \bot \bor f_2~x = \bot)~\bot~{\pair{f_1~x,f_2~x}}
}
\end{equation*}
\end{varwidth}
\hspace{0.25in}
\begin{varwidth}{\textwidth}
\begin{equation*}
\lzfcsplit{
	&\ifbot : (X \tto Bool_\bot) \tto (1 \tto (X \tto Y_\bot)) \tto (1 \tto (X \tto Y_\bot)) \\
	&\tab\tab\tto (X \tto Y_\bot) \\
	&\ifbot~f_1~f_2~f_3~x \ := \
		\ilzfccase{f_1~x}{true & f_2~0~x \\ false & f_3~0~x \\ else & \bot}
}
\end{equation*}
\end{varwidth}
\caption{Bottom arrow definitions.}
\label{fig:bottom-arrow-defs}
\end{figure*}

XXX: the standard Kleisli conversion of the Maybe monad (using a \tlzfc{\bot} instead of Just and Maybe), simplified; arrow laws therefore hold (XXX: check terminology)

XXX: point out that \tlzfc{\ifbot} receives thunks, and remind readers that \tlzfc{1 = \set{0}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Deriving the Mapping Arrow}

XXX: intermediate step between the bottom and preimage arrows; will not be implemented (no approximation will be implemented, either); computations are in terms of mappings, on which we can apply theorems from measure theory directly

XXX: the type of mapping arrow computations
\begin{equation}
\lzfc{
	X \mapto Y \ ::= \ Set~X \tto (X \pto Y)
}
\end{equation}
XXX: notice \tlzfc{X \pto Y}, not \tlzfc{X \pto Y_\bot}

XXX: motivate removal of bottom

Lifting a bottom arrow computation \tlzfc{f : X \tto Y_\bot} to the mapping arrow requires restricting \tlzfc{f}'s domain to a subset of \tlzfc{X} for which \tlzfc{f} does not return \tlzfc{\bot}.
It is helpful to have a standalone function \tlzfc{domain_\bot} that computes such domains, so we define that first, and \tlzfc{\arrmap} in terms of \tlzfc{domain_\bot}:
\begin{equation}
\lzfcsplit{
	&domain_\bot : (X \tto Y_\bot) \tto Set~X \tto Set~X \\
	&domain_\bot~f~A \ := \ preimage~f\restrict{A}~((image~f~A) \w \set{\bot}) \\
\\
	&\arrmap : (X \tto Y_\bot) \tto (X \mapto Y) \\
	&\arrmap~f~A \ := \ \ilzfclet{A' & domain_\bot~f~A}{f\restrict{A'}}
}
\end{equation}

XXX: the default equality relation, which for \lzfclang terms is alpha equivalence of reduced terms, will not do; need something more extensional

\begin{definition}[Mapping arrow equivalence]
Two mapping arrow computations \tlzfc{g_1 : X \mapto Y} and \tlzfc{g_2 : X \mapto Y} are equivalent, written \tlzfc{g_1 \eqmap g_2}, when \tlzfc{g_1~A = g_2~A} for all \tlzfc{A \subseteq X}.
\end{definition}


\subsection{Natural Transformation}

The clearest way to ensure that mapping arrow computations mean what we think they mean is to derive each combinator in a way that makes \tlzfc{\arrmap} into a \keyword{natural transformation}: a transformation that maintains the overall structure of the computations.
As a bonus, the arrow laws naturally hold.

Formally, for \tlzfc{\arrmap} to be a natural transformation, we require the following identities to hold:
\begin{equation}
\lzfcsplit{
	&\arrmap~(\pairbot~f_1~f_2) \ \eqmap \ \pairmap~(\arrmap~f_1)~(\arrmap~f_2)
}
\label{eqn:arrmap-distributes-over-pair}
\end{equation}
\begin{equation}
\lzfcsplit{
	&\arrmap~(\compbot~f_1~f_2) \ \eqmap \ \compmap~(\arrmap~f_1)~(\arrmap~f_2)
}
\label{eqn:arrmap-distributes-over-comp}
\end{equation}
\begin{equation}
\lzfcsplit{
	&\arrmap~(\ifbot~f_1~f_2~f_3) \ \eqmap \ \\
	&\tab\ifmap~(\arrmap~f_1)~(\fun{0}{\arrmap~(f_2~0)})~(\fun{0}{\arrmap~(f_3~0)})
}
\label{eqn:arrmap-distributes-over-if}
\end{equation}
i.e. \tlzfc{\arrmap} must distribute over bottom arrow computations.

Fig.~\ref{fig:mapping-arrow-defs} shows the final result of deriving the mapping arrow as a natural transformation from the bottom arrow.

\begin{figure*}[t]\centering
\begin{varwidth}{\textwidth}
\begin{equation*}
\lzfcsplit{
	&X \mapto Y \ ::= \ Set~X \tto (X \pto Y) \\
\\
\\
	&\arrmap : (X \tto Y_\bot) \tto (X \mapto Y) \\
	&\arrmap~f~A \ := \ \ilzfclet{A' & domain_\bot~f~A}{f\restrict{A'}} \\
\\
	&\compmap : (X \mapto Y) \tto (Y \mapto Z) \tto (X \mapto Z) \\
	&\compmap~g_1~g_2~A \ := \ 
		\ilzfclet{
			g_1' & g_1~A \\
			g_2' & g_2~(range~g_1')
		}{g_2' \circ\map g_1'} \\
\\
	&\pairmap : (X \mapto Y) \tto (X \mapto Z) \tto (X \mapto \pair{Y,Z}) \\
	&\pairmap~g_1~g_2~A \ := \ \pair{g_1~A,g_2~A}\map
}
\end{equation*}
\end{varwidth}
\hspace{0.25in}
\begin{varwidth}{\textwidth}
\begin{equation*}
\lzfcsplit{
	&\ifmap : (X \mapto Bool) \tto (1 \tto (X \mapto Y)) \tto (1 \tto (X \mapto Y)) \\
	&\tab\tab\tto (X \mapto Y) \\
	&\ifmap~g_1~g_2~g_3~A \ := \ \\
	&\tab\ilzfclet{
			g_1' & g_1~A \\
			g_2' & lazy\map~(g_2~0)~(preimage~g_1'~\set{true}) \\
			g_3' & lazy\map~(g_3~0)~(preimage~g_1'~\set{false}) \\
			A' & (domain~g_2') \u (domain~g_3')
		}{\fun{x \in A'}{if~(g_1'~x)~(g_2'~x)~(g_3'~x)}} \\
\\
\\
	&domain_\bot : (X \tto Y_\bot) \tto Set~X \tto Set~X \\
	&domain_\bot~f~A \ := \ preimage~f\restrict{A}~((image~f~A) \w \set{\bot}) \\
\\
	&lazy\map : (X \mapto Y) \tto (X \mapto Y) \\
	&lazy\map~g~A \ := \ if~(A = \emptyset)~\emptyset~(g~A) \\
}
\end{equation*}
\end{varwidth}
\caption{Mapping arrow definitions.}
\label{fig:mapping-arrow-defs}
\end{figure*}

\begin{theorem}[Mapping arrow correctness]
\tlzfc{\arrmap} is a natural transformation from the bottom arrow.
\end{theorem}
\begin{proof}
By structural induction; cases follow.
\end{proof}

Each case---pairing, composition, conditional---is proved by construction, yielding an implementation.

\subsection{Case: Pairing}

We ensure~\eqref{eqn:arrmap-distributes-over-pair} holds by construction and equational reasoning.
Starting with its left-hand side, we first expand definitions. For any \tlzfc{A : Set~X},
\begin{equation}
\lzfcsplit{
	&\arrmap~(\pairbot~f_1~f_2)~A
\vspace{4pt}\\
	&\tab = \ \arrmap~(\fun{x}{if~(f_1~x = \bot \bor f_2~x = \bot)~\bot~{\pair{f_1~x,f_2~x}}})~A
\vspace{4pt}\\
	&\tab = \ 
		\ilzfclet{
			f & \fun{x}{if~(f_1~x = \bot \bor f_2~x = \bot)~\bot~{\pair{f_1~x,f_2~x}}} \\
			A' & domain_\bot~f~A
		}{f\restrict{A'}}
}
\end{equation}
Next, we replace the definition of \tlzfc{A'} with one that does not depend on \tlzfc{f}, and rewrite in terms of \tlzfc{\arrmap~f_1} and \tlzfc{\arrmap~f_2}:
\begin{equation}
\lzfcsplit{
	&\arrmap~(\pairbot~f_1~f_2)~A
\vspace{4pt}\\
	&\tab = \ 
		\ilzfclet{
			A_1 & (domain_\bot~f_1~A) \\
			A_2 & (domain_\bot~f_2~A) \\
			A' & A_1 \i A_2
		}{\fun{x \in A'}{\pair{f_1~x,f_2~x}}}
\vspace{4pt}\\
	&\tab = \ 
		\ilzfclet{
			g_1 & \arrmap~f_1~A \\
			g_2 & \arrmap~f_2~A \\
			A' & (domain~g_1) \i (domain~g_2)
		}{\fun{x \in A'}{\pair{g_1~x,g_2~x}}}
\vspace{4pt}\\
	&\tab = \ \pair{\arrmap~f_1~A, \arrmap~f_2~A}\map
}
\end{equation}
Substituting \tlzfc{g_1} for \tlzfc{\arrmap~f_1} and \tlzfc{g_2} for \tlzfc{\arrmap~f_2} in the last equality gives the definition for \tlzfc{\pairmap}:
\begin{equation}
\lzfcsplit{
	&\pairmap : (X \mapto Y) \tto (X \mapto Z) \tto (X \mapto \pair{Y,Z}) \\
	&\pairmap~g_1~g_2~A \ := \ \pair{g_1~A,g_2~A}\map
}
\end{equation}
Thus, \tlzfc{\arrmap} distributes over \tlzfc{\pairbot} by construction.

\subsection{Case: Composition}

The derivation of \tlzfc{\compmap} is similar to that of \tlzfc{\pairmap} but a little more involved.

XXX: include it?

\subsection{Case: Conditional}

The derivation of \tlzfc{\ifmap} needs some care to maintain laziness of conditional branches in the presence of recursion.

We will use as an example the following bottom arrow computation, which returns \tlzfc{true} when applied to \tlzfc{true} and diverges on \tlzfc{false}:
\begin{equation}
\lzfcsplit{
	&halts@on@true_\bot \ := \ \\
	&\tab\ifbot~id~(\fun{0}{id})~(\fun{0}{halts@on@true_\bot})
}
\end{equation}
Its natural transformation to the mapping arrow should diverge only if applied to a set containing \tlzfc{false}.

Starting with the left-hand-side of~\eqref{eqn:arrmap-distributes-over-if}, we expand definitions, and simplify \tlzfc{f} by restricting it to a domain for which \tlzfc{f_1~x} cannot be \tlzfc{\bot}:
\begin{equation}
\lzfcsplit{
	&\arrmap~(\ifbot~f_1~f_2~f_3)~A
\vspace{4pt}\\
	&\tab = \ 
		\ilzfclet{
			f & \fun{x}{\ilzfccase{f_1~x}{true & f_2~0~x \\ false & f_3~0~x \\ else & \bot}} \\
			A' & domain_\bot~f~A
		}{f\restrict{A'}}
\vspace{4pt}\\
	&\tab = \ 
		\ilzfclet{
			A_2 & preimage~f_1\restrict{A}~\set{true} \\
			A_3 & preimage~f_1\restrict{A}~\set{false} \\
			f & \fun{x}{if~(f_1~x)~(f_2~0~x)~(f_3~0~x)} \\
			A' & domain_\bot~f~(A_2 \u A_3)
		}{f\restrict{A'}}
}
\end{equation}
It is tempting at this point to finish by simply converting bottom arrow computations to the mapping arrow; i.e.
\begin{equation}
\lzfcsplit{
	&\arrmap~(\ifbot~f_1~f_2~f_3)~A
\vspace{4pt}\\
	&\tab = \ 
		\ilzfclet{
			g_1 & \arrmap~f_1~A \\
			A_2 & preimage~g_1~\set{true} \\
			A_3 & preimage~g_1~\set{false} \\
			g_2 & \arrmap~(f_2~0)~A_2 \\
			g_3 & \arrmap~(f_3~0)~A_3 \\
			A' & (domain~g_2) \u (domain~g_3)
		}{\fun{x \in A'}{if~(g_1~x)~(g_2~x)~(g_3~x)}}
}
\end{equation}
This is close to correct.
Unfortunately, for \tlzfc{halts@on@true_\bot}, computing \tlzfc{g_3 := \arrmap~(f_3~0)~A_3} always diverges.
Wrapping the branch computations \tlzfc{g_2} and \tlzfc{g_3} in thunks will not help because \tlzfc{A'} is computed from their domains.

Note that the ``true'' branch needs to be taken only if \tlzfc{A_2} is nonempty; similarly for the ``false'' branch and \tlzfc{A_3}.
Further, applying a mapping arrow computation to \tlzfc{\emptyset} should always yield the empty mapping \tlzfc{\emptyset}.
We can therefore maintain laziness in conditional branches by applying \tlzfc{\arrmap~(f_2~0)} and \tlzfc{\arrmap~(f_3~0)} only to nonempty sets, using
\begin{equation}
\lzfcsplit{
	&lazy\map : (X \mapto Y) \tto (X \mapto Y) \\
	&lazy\map~f~A \ := \ if~(A = \emptyset)~\emptyset~(f~A) \\
\\
	&\arrmap~(\ifbot~f_1~f_2~f_3)~A
\vspace{4pt}\\
	&\tab = \ 
		\ilzfclet{
			g_1 & \arrmap~f_1~A \\
			g_2 & lazy\map~(\arrmap~(f_2~0))~(preimage~g_1~\set{true}) \\
			g_3 & lazy\map~(\arrmap~(f_3~0))~(preimage~g_1~\set{false}) \\
			A' & (domain~g_2) \u (domain~g_3)
		}{\fun{x \in A'}{if~(g_1~x)~(g_2~x)~(g_3~x)}}
}
\end{equation}
For \tlzfc{halts@on@true_\bot}, \tlzfc{lazy\map~(\arrmap~(f_3~0))~A_3} does not diverge when \tlzfc{A_3} is empty.

\subsection{Super-Saver Theorems}

The following two theorems are easy consequences of the fact that \tlzfc{\arrmap} is a natural transformation.

\begin{corollary}
Let \tlzfc{f : X \tto Y_\bot}, \tlzfc{A \subseteq X}, and \tlzfc{g : X \mapto Y} such that \tlzfc{g \ \eqmap \ \arrmap~f}.
Then \tlzfc{g~A} diverges if and only if there exists an \tlzfc{x \in A} for which \tlzfc{f~x} diverges.
\end{corollary}

\begin{corollary}
\tlzfc{\arrmap}, \tlzfc{\pairmap} and \tlzfc{\compmap} define an arrow.
\end{corollary}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Preimage Mappings}

XXX: almost ready to derive the preimage arrow; unfortunately, data structures used in measure theory do not always lend themselves to approximation

On a computer, we will not often have the luxury of testing each function input to see whether it belongs in a preimage set.
Even for finite domains, doing so is often intractable.

To compute with abstract, infinite sets in the language implementation, we need to be able to work with preimages in the semantics without resorting to applying functions to points.
We therefore introduce \mykeyword{preimage mappings}. The function space is constructed by
\begin{equation}
\lzfcsplit{
	&X \prepto Y \ := \ \powerset~Y \pto \powerset~X
}
\end{equation}

XXX: converting a mapping to a preimage mapping:
\begin{equation}
\lzfcsplit{
	&pre : (X \pto Y) \tto Set~(Set~Y) \tto (X \prepto Y) \\
	&pre~g~\B \ := \ \fun{B \in \B}{preimage~g~B}
}
\end{equation}
Note: \tlzfc{\B} is not necessarily a $\sigma$-algebra

XXX: preimage mappings are defined for the \emph{range} of a mapping, but preimages can be computed for any subset of a mapping's \emph{codomain}; use this function to compute preimages of any measurable codomain subset:
\begin{equation}
\lzfcsplit{
	&pre@ap : (X \prepto Y) \tto Set~Y \tto Set~X \\
	&pre@ap~h~B \ := \ h~(B \i \U(domain~h))
}
\end{equation}

XXX: for measurable sets in a function's codomain, using \tlzfc{pre@ap} to compute preimages from a preimage mapping is the same as computing them from the original mapping:
\begin{theorem}[\tlzfc{pre@ap} of measurable sets]
Let \tlzfc{g \in X \pto Y}, \tlzfc{\B'} a $\sigma$-algebra on \tlzfc{Y}, and \tlzfc{\B := \sigma@trace~\B'~(range~g)}.
Then for all \tlzfc{B \in \B'}, \tlzfc{pre@ap~(pre~g~\B)~B = preimage~g~B}.
\label{thm:pre-like-preimage}
\end{theorem}
\begin{proof}
Expanding the definitions of \tlzfc{pre@ap} and \tlzfc{pre}, and substituting \tlzfc{\U(domain~h) = range~g} yields
\begin{equation}
\lzfcsplit{
	pre@ap~(pre~g~\B)~B
		&\ = \ \ilzfclet{
							h & \fun{B \in \B}{preimage~g~B}
						}{h~(B \i \U(domain~h))}
\vspace{4pt} \\
		&\ = \ \ilzfclet{
							h & \fun{B \in \B}{preimage~g~B}
						}{h~(B \i (range~g))}
}
\end{equation}
By definition of \tlzfc{\sigma@trace}, \tlzfc{B \i (range~g) \in \B'}, so
\begin{equation}
\lzfcsplit{
	pre@ap~(pre~g~\B)~B
		&\ = \ preimage~g~(B \i (range~g)) \\
		&\ = \ preimage~g~B
}
\end{equation}
\end{proof}



\subsection{Generated Preimage Mappings}

XXX: for pairing, will need to define preimage mappings for a generating family, then close the domain (and thus the range) under $\sigma$-algebra operations

XXX: proceeds just like generating $\sigma$-algebras: define a single, monotone operation:
\begin{equation}
\lzfcsplit{
	&pre@comps : (X \prepto Y) \tto (X \prepto Y) \\
	&pre@comps~h \ := \ \\
	&\tab\ilzfclet{
			\B & domain~h
		}{\setb{\pair{B_1 \w B_2,(h~B_1) \w (h~B_2)}}{B_1,B_2 \in \B}} \\
\\
	&pre@unions : (X \prepto Y) \tto (X \prepto Y) \\
	&pre@unions~h \ := \ \\
	&\tab\ilzfclet{
			\B & domain~h
		}{\setb{\pair{\U \B', \U (image~h~\B')}}{\B' \subseteq \B \band |\B'| \leq \omega}} \\
\\
	&pre@ops : (X \prepto Y) \tto (X \prepto Y) \\
	&pre@ops~h \ := \ \set{\pair{\emptyset,\emptyset}} \u (pre@comps~h) \u (pre@unions~h)
}
\end{equation}
XXX: then apply \tlzfc{close} to it with a sufficient number of iterations:
\begin{equation}
\lzfcsplit{
	&pre@close : (X \prepto Y) \tto (X \prepto Y) \\
	&pre@close \ := \ close~pre@ops~\omega_1
}
\end{equation}

XXX: central fact: closing a preimage mapping defined for a generating family is equivalent to defining that preimage mapping for the generated $\sigma$-algebra
\begin{theorem}
Let \tlzfc{f \in X \pto Y} and \tlzfc{\B} a generating family for \tlzfc{Y}.
Then \tlzfc{pre@close~(pre~f~\B) = pre~f~(\sigma@close~\B)}.
\label{thm:close-distributes-over-pre}
\end{theorem}
\begin{proof}
By transfinite induction, noting that the preimage of \tlzfc{\emptyset} under any function is \tlzfc{\emptyset}, and that preimages distribute over complements and unions.
\end{proof}

XXX: as with mappings, it helps to have basic composition and pairing functions for preimage mappings

\subsection{Preimage Mapping Composition}

XXX: moar wurds in this section

\begin{equation}
\lzfcsplit{
	&(\circ\pre) : (Y \prepto Z) \tto (X \prepto Y) \tto (X \prepto Z) \\
	&h_2 \circ\pre h_1 \ := \ \fun{C \in domain~h_2} pre@ap~h_1~(h_2~C)
}
\end{equation}

\begin{lemma}[Preimages under composition]
Let \tlzfc{g_1 \in X \pto Y} and \tlzfc{g_2 \in Y \pto Z}.
Then for all \tlzfc{C \subseteq Z}, \tlzfc{preimage~(g_2 \circ\map g_1)~C} \tlzfc{=} \tlzfc{preimage~g_1~(preimage~g_2~C)}.
\label{lem:preimage-under-composition}
\end{lemma}

\begin{theorem}[Preimage mapping composition]
Let \tlzfc{g_1 \in X \pto Y}, \tlzfc{\B'} a $\sigma$-algebra on \tlzfc{Y}, and \tlzfc{\B} \tlzfc{:=} \tlzfc{\sigma@trace~\B'~(range~g_1)}.
Let \tlzfc{g_2 \in Y \pto Z}, \tlzfc{\C'} a $\sigma$-algebra on \tlzfc{Z}, and \tlzfc{\C} \tlzfc{:=} \tlzfc{\sigma@trace~\C'~(range~g_2)}.
Then for all \tlzfc{C \in \C'}, \tlzfc{pre@ap~((pre~g_2~\C) \circ\pre (pre~g_1~\B))~C} \tlzfc{=} \tlzfc{preimage~(g_2 \circ\map g_1)~C}.
\end{theorem}
\begin{proof}
Expand definitions and apply Theorem~\ref{thm:pre-like-preimage} and Lemma~\ref{lem:preimage-under-composition}.
\begin{equation}
\lzfcsplit{
	&pre@ap~((pre~g_2~\C) \circ\pre (pre~g_1~\B))~C
\vspace{4pt} \\
	&\tab = \ 
		\ilzfclet{
			h & \fun{C \in \C} pre@ap~(pre~g_1~\B)~((pre~g_2~\C)~C)
		}{h~(C \i \U(domain~h))}
\vspace{4pt} \\
	&\tab = \ 
		\ilzfclet{
			h & \fun{C \in \C} preimage~g_1~((pre~g_2~\C)~C)
		}{h~(C \i \U\C)}
\vspace{4pt} \\
	&\tab = \ preimage~g_1~((pre~g_2~\C)~(C \i \U\C))
\vspace{4pt} \\
	&\tab = \ preimage~g_1~(pre@ap~(pre~g_2~\C)~C)
\vspace{4pt} \\
	&\tab = \ preimage~g_1~(preimage~g_2~C)
\vspace{4pt} \\
	&\tab = \ preimage~(g_2 \circ\map g_1)~C
}
\end{equation}
\end{proof}

\subsection{Preimage Mapping Pairing}

XXX: moar wurds in this section

\begin{equation}
\lzfcsplit{
	&\pair{\cdot,\cdot}\pre : (X \prepto Y) \tto (X \prepto Z) \tto (X \prepto Y \times Z) \\
	&\pair{h_1,h_2}\pre \ := \ 
	\ilzfclet{
			\B & (domain~h_1) \boxtimes (domain~h_2) \\
			h & \fun{B_1 \times B_2 \in \B}{(h_1~B_1) \i (h_2~B_2)}
		}{pre@close~h}
}
\end{equation}

\begin{lemma}[Preimages of rectangles under pairing]
Let \tlzfc{g_1 \in X \pto Y} and \tlzfc{g_2 \in X \pto Z}.
Then for all \tlzfc{B_1 \subseteq Y} and \tlzfc{B_2 \subseteq Z}, \tlzfc{preimage~\pair{g_1,g_2}\map~(B_1 \times B_2)} \tlzfc{=} \tlzfc{(preimage~g_1~B_1)} \tlzfc{\i} \tlzfc{(preimage~g_2~B_2)}.
\label{lem:preimage-under-pairing}
\end{lemma}

\begin{theorem}[Preimage mapping pairing]
Let \tlzfc{g_1 \in X \pto Y}, \tlzfc{\B_1'} a $\sigma$-algebra on \tlzfc{Y}, and \tlzfc{\B_1} \tlzfc{:=} \tlzfc{\sigma@trace~\B_1'~(range~g_1)}.
Let \tlzfc{g_2 \in X \pto Z}, \tlzfc{\B_2'} a $\sigma$-algebra on \tlzfc{Z}, and \tlzfc{\B_2} \tlzfc{:=} \tlzfc{\sigma@trace~\B_2'~(range~g_2)}.
Then for all \tlzfc{B \in \B_1' \otimes \B_2'}, \tlzfc{pre@ap~\pair{pre~g_1~\B_1,pre~g_2,\B_2}\pre~B} \tlzfc{=} \tlzfc{preimage~\pair{g_1,g_2}\map~B}.
\label{thm:preimage-mapping-pairing}
\end{theorem}
\begin{proof}
Expand definitions, substitute \tlzfc{h_1} and \tlzfc{h_2}, expand definition of \tlzfc{pre}, apply Lemma~\ref{lem:preimage-under-pairing}, rewrite in terms of \tlzfc{pre}, apply Theorem~\ref{thm:close-distributes-over-pre}, rewrite in terms of ``\tlzfc{\otimes}'', and apply Theorem~\ref{thm:pre-like-preimage}.
\begin{equation}
\lzfcsplit{
	&pre@ap~\pair{pre~g_1~\B_1, pre~g_2~\B_2}\pre~B
\vspace{4pt} \\
	&\tab = \ 
		\ilzfclet{
			h_1 & pre~g_1~\B_1 \\
			h_2 & pre~g_2~\B_2 \\
			\B & rects~(domain~h_1)~(domain~h_2) \\
			h & \fun{B_1 \times B_2 \in \B}{(h_1~B_1) \i (h_2~B_2)} \\
		}{pre@ap~(pre@close~h)~B}
\vspace{4pt} \\
	&\tab = \ 
		\ilzfclet{
			\B & rects~\B_1~\B_2 \\
			h & \lzfcsplit{&\fun{B_1 \times B_2 \in \B} \\ &\tab (pre~g_1~\B_1~B_1) \i (pre~g_2~\B_2~B_2)} \\
		}{pre@ap~(pre@close~h)~B}
\vspace{4pt} \\
	&\tab = \ 
		\ilzfclet{
			\B & rects~\B_1~\B_2 \\
			h & \lzfcsplit{&\fun{B_1 \times B_2 \in \B} \\ &\tab (preimage~g_1~B_1) \i (preimage~g_2~B_2)} \\
		}{pre@ap~(pre@close~h)~B}
\vspace{4pt} \\
	&\tab = \ 
		\ilzfclet{
			\B & rects~\B_1~\B_2 \\
			h & \fun{B \in \B}{preimage~\pair{g_1,g_2}\map~B} \\
		}{pre@ap~(pre@close~h)~B}
\vspace{4pt} \\
	&\tab = \ 
		\ilzfclet{
			\B & rects~\B_1~\B_2 \\
		}{pre@ap~(pre@close~(pre~\pair{g_1,g_2}\map~\B))~B}
\vspace{4pt} \\
	&\tab = \ 
		\ilzfclet{
			\B & rects~\B_1~\B_2 \\
		}{pre@ap~(pre~\pair{g_1,g_2}\map~(\sigma@close~\B))~B}
\vspace{4pt} \\
	&\tab = \ pre@ap~(pre~\pair{g_1,g_2}\map~(\B_1 \otimes \B_2))~B
\vspace{4pt} \\
	&\tab = \ preimage~\pair{g_1,g_2}\map~B
}
\end{equation}
\end{proof}

\section{The Preimage Arrow}

XXX: intro

XXX: to define standard $\sigma$-algebras, we need a universal set $\Univ$ and a universal $\sigma$-algebra $\Un$

XXX: for any subset \tlzfc{A \subseteq \Univ}, \tlzfc{\sigma} returns the \mykeyword{standard $\sigma$-algebra} for \tlzfc{A}
\begin{equation}
\lzfcsplit{
	&\sigma : Set~\Univ \tto Set~(Set~\Univ) \\
	&\sigma~A \ := \ \sigma@trace~\Un~A
}
\end{equation}

A preimage arrow computation is a function from a domain to a mapping from measurable output sets to measurable input sets (where the input sets are restricted to the given domain)


\begin{equation}
\lzfcsplit{
	X \preto Y \ ::= \ Set~X \tto (X \prepto Y)
}
\end{equation}
where \tlzfc{X} and \tlzfc{Y} are subsets of \tlzfc{\Univ}

\begin{equation}
\lzfcsplit{
	&\arrpre : (X \mapto Y) \tto (X \preto Y) \\
	&\arrpre~g~A \ := \ \ilzfclet{g' & g~A \\ \B & \sigma~(range~g')}{pre~g'~\B}
}
\end{equation}

\begin{definition}[Preimage arrow equivalence]
Two preimage arrow computations \tlzfc{h_1 : X \preto Y} and \tlzfc{h_2 : X \preto Y} are equivalent, written \tlzfc{h_1 \eqpre h_2}, when 
for any $\sigma$-algebra \tlzfc{\B} for \tlzfc{Y}, \tlzfc{pre@ap~(h_1~A)~B = pre@ap~(h_2~A)~B} for all \tlzfc{A \subseteq X} and \tlzfc{B \in \B}.
\end{definition}

\subsection{Natural Transformation}

XXX: ensuring \tlzfc{\arrpre} is a natural transformation from the mapping arrow...

Formally, for \tlzfc{\arrpre} to be a natural transformation,
\begin{equation}
\lzfcsplit{
	\arrpre~(\pairmap~g_1~g_2) \ \eqpre \ \pairpre~(\arrpre~g_1)~(\arrpre~g_2)
}
\label{eqn:arrpre-distributes-over-pairmap}
\end{equation}
\begin{equation}
\lzfcsplit{
	\arrpre~(\compmap~g_1~g_2) \ \eqpre \ \comppre~(\arrpre~g_1)~(\arrpre~g_2)
}
\label{eqn:arrpre-distributes-over-compmap}
\end{equation}
\begin{equation}
\lzfcsplit{
	&\arrpre~(\ifmap~g_1~g_2~g_3) \ \eqpre \ \\
	&\tab\ifpre~(\arrpre~g_1)~(\fun{0}{\arrpre~(g_2~0)})~(\fun{0}{\arrpre~(g_3~0)})
}
\label{eqn:arrpre-distributes-over-compmap}
\end{equation}
i.e. \tlzfc{\arrpre} must distribute over mapping arrow computations.

Fig.~\ref{fig:preimage-arrow-defs} shows the final result of deriving the preimage arrow as a natural transformation from the mapping arrow.

\begin{figure*}[t]\centering
\begin{varwidth}{\textwidth}
\begin{equation*}
\lzfcsplit{
}
\end{equation*}
\end{varwidth}
\hspace{0.25in}
\begin{varwidth}{\textwidth}
\begin{equation*}
\lzfcsplit{
}
\end{equation*}
\end{varwidth}
\caption{Preimage arrow definitions.}
\label{fig:preimage-arrow-defs}
\end{figure*}

\begin{theorem}[Preimage arrow correctness]
\tlzfc{\arrpre} is a natural transformation from the mapping arrow.
\end{theorem}
\begin{proof}
By structural induction; cases follow.
\end{proof}

\subsection{Case: Pairing}

Starting with the left-hand side of~\eqref{eqn:arrpre-distributes-over-pairmap}, we expand definitions and apply Theorem~\ref{thm:pre-like-preimage}:
\begin{equation}
\lzfcsplit{
	&pre@ap~(\arrpre~(\pairmap~g_1~g_2)~A)~B
\vspace{4pt} \\
	&\tab = \ 
		\ilzfclet{
			g' & \pair{g_1~A, g_2~A}\map \\
			\B & \sigma~(range~g') \\
			h & pre~g'~\B
		}{pre@ap~h~B}
\vspace{4pt} \\
	&\tab = \ preimage~\pair{g_1~A,g_2~A}\map~B
}
\end{equation}
Next, we apply Theorem~\ref{thm:preimage-mapping-pairing} and replace \tlzfc{g_1} and \tlzfc{g_2} with \tlzfc{\arrpre~g_1} and \tlzfc{\arrpre~g_2}:
\begin{equation}
\lzfcsplit{
	&pre@ap~(\arrpre~(\pairmap~g_1~g_2)~A)~B
\vspace{4pt} \\
	&\tab = \ 
		\ilzfclet{
			g_1' & g_1~A \\
			g_2' & g_2~A \\
			\B_1 & \sigma~(range~g_1') \\
			\B_2 & \sigma~(range~g_2') \\
		}{pre@ap~\pair{pre~g_1'~\B_1, pre~g_2'~\B_2}\pre~B}
\vspace{4pt} \\
	&\tab = \
		\ilzfclet{
			h_1 & \arrpre~g_1~A \\
			h_2 & \arrpre~g_2~A \\
		}{pre@ap~\pair{h_1, h_2}\pre~B}
}
\end{equation}
Substituting \tlzfc{h_1} for \tlzfc{\arrpre~g_1} and \tlzfc{h_2} for \tlzfc{\arrpre~g_2} in the last equality gives the definition for \tlzfc{\pairpre}:
\begin{equation}
\lzfcsplit{
	&\pairpre : (X \preto Y) \tto (X \preto Z) \tto (X \preto Y \times Z) \\
	&\pairpre~h_1~h_2~A \ := \ \pair{h_1~A,h_2~A}\pre
}
\end{equation}


\subsection{Case: Composition}

XXX: Starting with the left-hand side of~\eqref{eqn:arrpre-distributes-over-compmap}, we expand definitions...
\begin{equation}
\lzfcsplit{
	&pre@ap~(\arrpre~(\compmap~g_1~g_2)~A)~C
\vspace{4pt} \\
	&\tab = \ 
		\ilzfclet{
			g_1' & g_1~A \\
			g_2' & g_2~(range~g_1') \\
			A' & preimage~g_1'~(domain~g_2') \\
			g' & \fun{x \in A'}{g_2'~(g_1'~x)} \\
			\C & \sigma~(range~g') \\
		}{pre@ap~(pre~g'~\C)~C}
}
\end{equation}

\subsection{Case: Conditional}

XXX: do this


\subsection{Super-Saver Theorems}

The following two theorems are easy consequences of the fact that \tlzfc{\arrpre} is a natural transformation.

\begin{corollary}
Let \tlzfc{g : X \mapto Y}, \tlzfc{A \subseteq X}, and \tlzfc{h : X \preto Y} such that \tlzfc{h \ \eqmap \ \arrpre~g}.
Then \tlzfc{h~A} diverges if and only if \tlzfc{g~A} diverges.
\end{corollary}

\begin{corollary}
\tlzfc{\arrpre}, \tlzfc{\pairpre} and \tlzfc{\comppre} define an arrow.
\end{corollary}


\section{Preimages of Partial Functions}

\begin{equation}
\lzfcsplit{
	&\bot\pre : X \preto \emptyset \\
	&\bot\pre \ := \ \arrpre~(\arrmap~\fun{x}\bot)
}
\end{equation}


%\appendix
%\section{Appendix Title}
%This is the text of the appendix, if you need one.

%\acks
%Acknowledgments, if needed.

\bibliographystyle{abbrvnat}
\bibliography{plt}

\end{document}
