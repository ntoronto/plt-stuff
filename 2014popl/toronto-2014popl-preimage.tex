%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\input{local-macros.tex}

\mathversion{sans}

\newcommand{\restrict}[1]{\lvert_{#1}}
\newcommand{\pto}{\rightharpoonup}
\newcommand{\Univ}{\mathbb{U}}
\newcommand{\Un}{\mathcal{U}}

\newcommand{\arrowarr}{\ensuremath{arr}}
\newcommand{\arrowcomp}{\ensuremath{{>}\mspace{-6mu}{>}\mspace{-6mu}{>}}}
%\newcommand{\arrowpair}{\ensuremath{\&\mspace{-5mu}\&\mspace{-5mu}\&}}
\newcommand{\arrowpair}{\ensuremath{pair}}
\newcommand{\arrowif}{\ensuremath{if}}
\newcommand{\arrowlazy}{\ensuremath{lazy}}
\newcommand{\arrowapp}{\ensuremath{app}}
\newcommand{\arrowrun}{\ensuremath{run}}

\newcommand{\arrbot}{\arrowarr_\bot}
\newcommand{\compbot}{\arrowcomp_\bot}
\newcommand{\pairbot}{\arrowpair_\bot}
\newcommand{\ifbot}{\arrowif_\bot}

\newcommand{\map}{_\mathrm{map}}
\DeclareMathOperator{\mapto}{\rightsquigarrow_{\mspace{-21mu}\map}}
\DeclareMathOperator{\eqmap}{\mbox{\ensuremath{=_{\mspace{-19mu}\map}}}}
\newcommand{\arrmap}{\arrowarr\map}
\newcommand{\compmap}{\arrowcomp\map}
\newcommand{\pairmap}{\arrowpair\map}
\newcommand{\ifmap}{\arrowif\map}

\newcommand{\pre}{_\mathrm{pre}}
\DeclareMathOperator{\preto}{\rightsquigarrow_{\mspace{-19mu}\pre}}
\DeclareMathOperator{\eqpre}{=_{\mspace{-17mu}\pre}}
\newcommand{\arrpre}{\arrowarr\pre}
\newcommand{\comppre}{\arrowcomp\pre}
\newcommand{\pairpre}{\arrowpair\pre}
\newcommand{\ifpre}{\arrowif\pre}

\newcommand{\prepto}{\pto_{\mspace{-19mu}\pre}}


\begin{document}

\conferenceinfo{POPL '14}{January 22-24, 2014, San Diego, CA, USA}
\copyrightyear{2014}
\copyrightdata{[to be supplied]} 

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Running Probabilistic Programs Backward}
%\subtitle{Subtitle Text, if any}

\authorinfo{Neil Toronto \and Jay McCarthy}
           {PLT @ Brigham Young University}
           {ntoronto@racket-lang.org \and jay@cs.byu.edu}
%\authorinfo{Chris Grant}
%           {Brigham Young University}
%           {grant@math.byu.edu}
\maketitle

\begin{abstract}
XXX
\end{abstract}

\category{XXX-CR-number}{XXX-subcategory}{XXX-third-level}

\terms
XXX, XXX

\keywords
XXX, XXX

TODO: equivalence relation for \lzfclang terms, that at least handles divergence

\section{Introduction}

\begin{enumerate}
	\item Define the \emph{bottom arrow}, type $X \tto Y_\bot$, a compilation target for first-order functions that may raise errors.
	\item Derive the \emph{mapping arrow} from the bottom arrow, type $X \mapto Y$. Its instances return extensional functions, or mappings---essentially infinite hash tables---that compute the same values as their corresponding bottom arrow computations, but have observable domains.
	\item Derive the \emph{preimage arrow} from the mapping arrow, type $X \preto Y$. Instances compute preimages under their corresponding mapping arrow instances.
	\item Derive \emph{XXX} from the preimage arrow. Instances compute conservative approximations of the preimages computed by their corresponding preimage arrow instances.
\end{enumerate}
Only the first and last artifacts---the bottom arrow and the XXX---can be implemented.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Mathematics and Metalanguage}

From here on, significant terms are introduced in \keyword{bold}, and significant terms we invent are introduced in \mykeyword{bold italics}.

We write all of the mathematics in this paper in \lzfclang~\cite{cit:toronto-2012flops-lzfc}, an untyped, call-by-value lambda calculus designed for manually deriving computable programs from contemporary mathematics.

Contemporary mathematics is generally done in \keyword{ZFC}: \keyword{Zermelo-Fraenkel} set theory extended with the axiom of \keyword{Choice} (equivalently \keyword{Cardinality}).
ZFC has only first-order functions and no general recursion, which makes implementing a language defined by a transformation into contemporary mathematics quite difficult.
The problem is exacerbated if implementing the language requires approximation.
Targeting \lzfclang instead allows creating a precise mathematical specification and deriving an approximating implementation without changing languages.

In \lzfclang, essentially every set is a value, as well as every lambda and every set of lambdas.
All operations, including operations on infinite sets, are assumed to complete instantly if they terminate.\footnote{An
example of a nonterminating \lzfclang function is one that attempts to decide whether other \lzfclang programs halt.}

Almost everything definable in contemporary mathematics can be formally defined by a finite \lzfclang program, except objects that most mathematicians would agree are nonconstructive.
More precisely, any object that \emph{must} be defined by a statement of existence and uniqueness without giving a bounding set is not definable by a \emph{finite} \lzfclang program.

Because \lzfclang includes an inner model of ZFC, essentially every contemporary theorem applies to \lzfclang programs without alteration.
Further, proofs about \lzfclang objects apply to contemporary mathematical objects.\footnote{Assuming the existence of a single inaccessible cardinal.}

In \lzfclang, algebraic data structures are encoded as sets; e.g. a \mykeyword{primitive ordered pair} of $x$ and $y$ is $\set{\set{x},\set{x,y}}$.
Only the \emph{existence} of encodings into sets is important, as it means data structures inherit a defining characteristic of sets: strictness.
More precisely, the lengths of paths to data structure leaves is unbounded, but each path must be finite.
Less precisely, data may be ``infinitely wide'' (such as $\Re$) but not ``infinitely tall'' (such as infinite trees and lists).

We assume data structures, including pairs, are encoded as \emph{primitive} ordered pairs with the first element a unique tag, so that they can be distinguished by checking tags.
Accessors such as $fst$ and $snd$ are trivial to define.

\lzfclang is untyped so its users can define an auxiliary type system that best suits their application area.
For this work, we use an informal, manually checked, polymorphic type system characterized by these rules:
\begin{itemize}
	\item A free lowercase type variable is universally quantified.
	\item A free uppercase type variable is a set.
	\item A set denotes a member of that set.
	\item $x \tto y$ denotes a partial function.
	\item $\pair{x,y}$ denotes a pair of values with types $x$ and $y$.
	\item $Set~x$ denotes a set with members of type $x$.
\end{itemize}
The type $Set~A$ denotes the same values as the powerset $\powerset~A$, and is the type of \emph{subsets} of $A$.
Similarly, the type $\pair{A,B}$ is equivalent to the product set $A \times B$.

Most \lzfclang programs are infinite.
We write finite programs in heavily sugared $\lambda$-calculus syntax, with an $if$ expression and these additional primitives:
\begin{equation}
\begin{aligned}
	\begin{aligned}
		\emptyset &: Set~x \\
		\omega &: Ord \\
		true &: Bool \\
		false &: Bool \\
		take &: Set~x \tto x \\
	\end{aligned}
	&\tab
	\begin{aligned}
		(\in) &: x \tto Set~x \tto Bool \\
		\powerset &: Set~x \tto Set~(Set~x) \\
		\U &: Set~(Set~x) \tto Set~x \\
		image &: (x \tto y) \tto Set~x \tto Set~y \\
		card &: Set~x \tto Ord \\
	\end{aligned} \\
\end{aligned}
\label{eqn:lzfc-prims}
\end{equation}
Shortly, $\emptyset$ is the empty set, $\omega$ is the cardinality of the natural numbers, $take$ removes the member from a singleton set, $(\in)$ is an infix operator that decides membership, $\powerset$ returns all the subsets of a set, $\U$ returns the union of a set of sets, $image$ applies a function to each member of a set and returns the set of return values, and $card$ returns the cardinality of a set.

We assume literal set notation such as $\set{0,1,2}$ is already defined in terms of set primitives.

\subsection{Internal and External Equality}

Set theory is defined by extending first-order logic with an axiom that defines equality to be extensional, and with axioms that ensure the existence of sets in the domain of discourse.
\lzfclang is defined by (conservatively) extending set theory with higher-order functions in the domain of discourse, and defining a reduction relation.
Thus, all our reasoning about \lzfclang programs is done in first-order logic.

While \lzfclang does not have an equality primitive, extensional equality can be recovered internally using the $(\in)$ primitive.
\emph{Internal} extensional equality is defined by
\begin{equation}
	x = y \ := \ x \in \set{y}
\end{equation}
which means
\begin{equation}
	(=) \ := \ \fun{x}\fun{y}{x \in \set{y}}
\end{equation}
Thus, $1 = 1$ reduces to $1 \in \set{1}$, which reduces to $true$.\footnote{Strictly speaking, \lzfclang has a big-step semantics, and $1 \in \set{1}$ can be extracted from the derivation tree for $1 = 1$.}
Because of the particular way \lzfclang's lambdas are added to the domain of discourse, for two lambda terms $f$ and $g$, $f = g$ reduces to $true$ when $f$ and $g$ are structurally identical modulo renaming.
For example, $(\fun{x}{x}) = (\fun{y}{y})$ reduces to $true$, but $(\fun{x}{2}) = (\fun{x}{1+1})$ reduces to $false$.

\emph{External} extensional equality is usually too fine-grained---moreso than the internal $(=)$.
For example, the terms $\set{(\fun{x}{x})~1,\,1}$ and $\set{1}$ are unequal, even though the term $\set{(\fun{x}{x})~1,\,1} = \set{1}$ reduces to $true$.
We will therefore not use external extensional equality, but instead understand truth statements such as ``$\mathit{e_1} = \mathit{e_2}$'' as shorthand for ``$\mathit{e_1} = \mathit{e_2}$ reduces to $true$.''

When we do not want an equality statement to require or guarantee convergence, we use a slightly weaker equivalence.

\begin{definition}[observational equivalence]
Two \lzfclang terms $\mathit{e_1}$ and $\mathit{e_2}$ are \keyword{observationally equivalent}, written $\mathit{e_1} \equiv \mathit{e_2}$, when $\mathit{e_1} = \mathit{e_2}$ or both $\mathit{e_1}$ and $\mathit{e_2}$ diverge.
\end{definition}

It could be helpful to introduce even coarser notions of equality, such as applicative or logical bisimilarity, but we do not want to deal with too much dissonance between external and internal equality.
We therefore introduce type-specific equivalence as needed.

\subsection{Additional Functions and Forms}

XXX: syntactic sugar: automatic currying, matching, sectioning rules, set comprehensions, cardinality, indexed unions

XXX: $A \pto B$ is the set of partial mappings...

XXX: put Englishy word thingies around the following so it's not just a wall of meaningless code:

\begin{equation}
\begin{aligned}
	&(\uplus) : Set~x \tto Set~x \tto Set~x \\
	&A \uplus B \ := \ if~(A \i B = \emptyset)~(A \u B)~(take~\emptyset)
\end{aligned}
\end{equation}

\begin{equation}
\begin{aligned}
	&restrict : (A \tto B) \tto \powerset~A \tto (A \pto B) \\
	&restrict~f~A' \ := \ image~(\fun{x}{(x, f~x)})~A'
\end{aligned}
\end{equation}

\begin{equation}
\begin{aligned}
	f\restrict{A} &\ :\equiv \ restrict~f~A \\
	\fun{x \in A}{e} &\ :\equiv \ (\fun{x}{e})\restrict{A}
\end{aligned}
\end{equation}

\begin{align}
	&\begin{aligned}
		&domain : (A \pto B) \tto Set~A \\
		&domain~f \ := \ image~fst~f \\
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		&range : (A \pto B) \tto Set~B \\
		&range~f \ := \ image~snd~f
	\end{aligned}
\end{align}

\begin{equation}
\begin{aligned}
	&preimage : (A \pto B) \tto Set~B \tto Set~A \\
	&preimage~f~B \ :=\ \setb{x \in domain~f}{f~x \in B}
\end{aligned}
\end{equation}

\begin{align}
	&\begin{aligned}
		&(\circ\map) : (Y \pto Z) \tto (X \pto Y) \tto (X \pto Z) \\
		&g_2 \circ\map g_1 \ := \ 
			\lzfclet{
				A & preimage~g_1~(domain~g_2)
			}{\fun{x \in A}{g_2~(g_1~x)}}
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		&\pair{\cdot,\cdot}\map : (X \pto Y) \tto (X \pto Z) \tto (X \pto Y \times Z) \\
		&\pair{g_1,g_2}\map \ := \ 
			\lzfclet{
				A & (domain~g_1) \i (domain~g_2)
			}{\fun{x \in A}{\pair{g_1~x,g_2~x}}}
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		&(\uplus\map) : (X \pto Y) \tto (X \pto Y) \tto (X \pto Y) \\
		&g_1 \uplus\map g_2 \ := \ 
			\lzfclet{
				A & (domain~g_1) \uplus (domain~g_2)
			}{g_1 \u g_2}
	\end{aligned}
\end{align}


\subsection{Ordinal Numbers and Transfinite Recursion}

The \keyword{ordinal numbers}, or values of type $Ord$, are an extension of the natural numbers to infinite lengths.
Ordinals are typically defined as the smallest sets that contain all their predecessors; e.g. the first four are
\begin{equation}
\begin{aligned}
	\begin{aligned}
		0 &\ := \ \emptyset \\
		1 &\ := \ \set{0}
	\end{aligned}
	&\tab\tab
	\begin{aligned}
		2 &\ := \ \set{0,1} \\
		3 &\ := \ \set{0,1,2}
	\end{aligned}
\end{aligned}
\end{equation}
The smallest infinite ordinal $\omega$ is the set of all finite ordinals.
Other infinite ordinals are defined in terms of $\omega$:
\begin{equation}
\begin{aligned}
	\omega &\ := \ \set{0,1,2,3,...} \\
	\omega+1 &\ := \ \set{0,1,2,3,...,\omega} \\
	\omega+2 &\ := \ \set{0,1,2,3,...,\omega,\omega+1} \\
	\omega+\omega &\ := \ \set{0,1,2,3,...,\omega,\omega+1,\omega+2,...}
\end{aligned}
\end{equation}
The above sets are all countable, meaning that their cardinality is $\omega$.
Generally, any ordinal $\alpha$ for which $\alpha = |\alpha|$ is also called a \keyword{cardinal number}.%\footnote{Think of ordinals as lengths of ordered collections, and cardinals as sizes of unordered collections.}

Ordinals are totally ordered by membership; i.e. $\beta < \alpha$ is equivalent to $\beta \in \alpha$.
Ordinals with an immediate predecessor (such as $3$ and $\omega+2$) are called \keyword{successor ordinals}.
Nonzero ordinals without an immediate predecessor (roughly, those whose literal representations end in ``$...$'') are called \keyword{limit ordinals}.

Limit ordinals allow writing terminating functions that recur infinitely many times.
Suppose we wanted a function that recursively generates all the integral successors of $0.5$.
Consider this first attempt, which can be written in any Turing-equivalent language:
\begin{equation}
\begin{aligned}
	&succs : \omega \tto Set~\Re \tto Set~\Re \\
	&\lzfcsplit{
		&succs~n~A \ := \ \\
		&\tab\lzfccase{n}{
			0 & A \\
			m+1 & A \u (image~(+~1.0)~(succs~m~A))
		}
	}
\end{aligned}
\end{equation}
This unfold over finite ordinals generates prefixes such as
\begin{equation}
\begin{aligned}
	succs~0~\set{0.5} &\ = \ \set{0.5} \\
	succs~1~\set{0.5} &\ = \ \set{0.5, 1.5} \\
	succs~2~\set{0.5} &\ = \ \set{0.5, 1.5, 2.5}
\end{aligned}
\end{equation}
but will never generate the full set of integral successors.

To close $\set{0.5}$ under increment, we can use \keyword{transfinite recursion}: unfolding over ordinals as above, but using an additional inductive case for limit ordinals:
\begin{equation}
\begin{aligned}
	&succs : Ord \tto Set~\Re \tto Set~\Re \\
	&\lzfcsplit{
		&succs~\alpha~A \ := \ \\
		&\tab\lzfccase{\alpha}{
			0 & A \\
			\beta+1 & A \u (image~(+~1.0)~(succs~\beta~A)) \\
			else & \U\limits_{\beta < \alpha} succs~\beta~A
		}
	}
\end{aligned}
\end{equation}
With this, we can compute the closure as desired:
\begin{equation}
\begin{aligned}
	&succs~\omega~\set{0.5} \ \\
		&\tab = \ (succs~0~\set{0.5}) \u (succs~1~\set{0.5}) \u \cdots \\
		&\tab = \ \set{0.5, 1.5, 2.5, 3.5, ...}
\end{aligned}
\end{equation}
The function terminates because each branch, though unbounded, is finite in length.
As with strict data structures, the shape of the computation is ``infinitely wide'' but not ``infinitely tall.''

The $succs$ function is a special case of a powerful general closure operator defined by
\begin{equation}
\begin{aligned}
	&close : (Set~x \tto Set~x) \tto Ord \tto Set~x \tto Set~x \\
	&close~f~\alpha~A \ := \ 
		\lzfccase{\alpha}{
			0 & A \\
			\beta+1 & A \u (f~(close~f~\beta~A)) \\
			else & \U\limits_{\beta < \alpha} close~f~\beta~A
		}
\end{aligned}
\end{equation}
With this, $succs := close~(image~(+~1.0))$.

The $close$ function can construct the least fixpoint of any monotone set function, if a fixpoint exists.
Such fixpoints include the languages of context-free grammars and the reduction relations defined by inductive rules in operational semantics.
(For almost all of these, only countably many iterations is sufficient.)
We will use $close$ to construct $\sigma$-algebras and preimages, two of the main objects of study in measure theory.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Measure Theory}

XXX: overview, with analogies to topology

\subsection{Sigma-Algebras}

XXX: motivate and define informally

\allowdisplaybreaks

Formally, using the following functions to generate $\emptyset$, complements, and countable unions from families of any type $x$:
\begin{align}
	&\begin{aligned}
		&\sigma@comps : Set~(Set~x) \tto Set~(Set~x) \\
		&\sigma@comps~\A \ := \ \setb{A \w A'}{A, A' \in \A} \\
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		&\sigma@unions : Set~(Set~x) \tto Set~(Set~x) \\
		&\sigma@unions~\A \ := \ \setb{\U\A'}{\A' \subseteq \A \band |\A'| \leq \omega} \\
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		&\sigma@ops : Set~(Set~x) \tto Set~(Set~x) \\
		&\sigma@ops~\A \ := \ \set{\emptyset} \u (\sigma@comps~\A) \u (\sigma@unions~\A) \\
	\end{aligned}
\end{align}
the following function identifies $\sigma$-algebras:
\begin{equation}
\begin{aligned}
	&\sigma@algebra? : Set~(Set~x) \tto Bool \\
	&\sigma@algebra?~\A \ := \ (\sigma@ops~\A) \subseteq \A
\end{aligned}
\end{equation}

Clearly, $\powerset~A$ for any set $A$ is a $\sigma$-algebra.
Unfortunately, this $\sigma$-algebra is ``too large''---a concept we will formalize when discussing measures.
(XXX: cover earlier, in motivation, using Banach-Tarski paradox?)

The \keyword{trace} of a family of subsets $\A$ with a set $A$ is the result of intersecting every $A' \in \A$ with $A$:
\begin{equation}
\begin{aligned}
	&trace : Set~(Set~x) \tto Set~x \tto Set~(Set~x) \\
	&trace~\A~A \ := \ \setb{A \i A'}{A' \in \A} \\
	&\A\restrict{A} \ := \ trace~\A~A
\end{aligned}
\end{equation}

\begin{lemma}[traces of $\sigma$-algebras are $\sigma$-algebras]
For any $\sigma$-algebra $\A$ and set $A$, $trace~\A~A$ is a $\sigma$-algebra on $A \i \U\A$.
\end{lemma}

\begin{lemma}[$\sigma@close$ distributes over $trace$]
For any family of subsets $\A$ and set $A$, $\sigma@close~(trace~\A~A) = trace~(\sigma@close~\A)~A$.
\label{lem:close-distributes-over-trace}
\end{lemma}


\subsection{Measurable Mappings}

XXX: define and characterize measurable mappings

XXX: images of measurable sets under measurable functions are not always measurable; e.g. projections

\subsection{Generated Sigma-Algebras}

Often, $\sigma$-algebras are too complicated to work with directly.
In such cases, we reason about them in terms of \keyword{generating families}: simpler families of sets that, when closed under $\sigma$-algebra operations, are $\sigma$-algebras with nice properties.

To generate $\sigma$-algebras, first note that $\sigma@ops$ is monotone and has an upper bound (the powerset $\sigma$-algebra).
Therefore, $close$ can generate a least fixpoint from it:
\begin{equation}
\begin{aligned}
	&\sigma@close : Set~(Set~x) \tto Set~(Set~x) \\
	&\sigma@close \ := \ close~\sigma@ops~\omega_1
\end{aligned}
\end{equation}
Here, $\omega_1$ is the \keyword{first uncountable ordinal}, or the least ordinal containing every countable ordinal.\footnote{\lzfclang does not decide the continuum hypothesis; i.e. whether $\omega_1 = |\Re|$.}

\begin{lemma}[generated $\sigma$-algebras]
Let $\A$ be a family of sets and $\A' := \sigma@close~\A$.
Then $\A'$ is the smallest $\sigma$-algebra for which $\A \subseteq \A'$.
\label{lem:generated-sigma-algebra}
\end{lemma}

Perhaps the most well-studied generated $\sigma$-algebras are \keyword{Borel $\sigma$-algebras}: those generated from topologies.
For example, if $\tau$ is the standard topology on $\Re$, containing the open intervals and uncountable unions of open intervals, then $\sigma@close~\tau$ is the Borel $\sigma$-algebra for that topology, containing all intervals (open, closed and half-open), and their countable unions and complements.

Other well-studied, generated $\sigma$-algebras are \keyword{product $\sigma$-algebras}: those generated from the rectangles of, or the pairwise products of sets from, other $\sigma$-algebras.
For example, the product $\sigma$-algebra $\A_1 \otimes \A_2$ can be defined by
\begin{align}
	&\begin{aligned}
		&(\boxtimes) : Set~(Set~x) \tto Set~(Set~y) \tto Set~(Set~\pair{x,y}) \\
		&\A_1 \boxtimes \A_2 \ := \ \setb{A_1 \times A_2}{A_1 \in \A_1, A_2 \in \A_2} \\
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		&(\otimes) : Set~(Set~x) \tto Set~(Set~y) \tto Set~(Set~\pair{x,y}) \\
		&\A_1 \otimes \A_2 \ := \ \sigma@close~(\A_1 \boxtimes \A_2) \\
	\end{aligned}
\end{align}
However, the following theorem is usually taken (somewhat less constructively) as the definition of $\A_1 \otimes \A_2$.
\begin{lemma}[projection mappings are product-measurable]
Let $\A := \A_1 \otimes \A_2$ and $A := \U\A$.
Then $\A$ is the smallest $\sigma$-algebra for which $fst\restrict{A}$ is $\A-\A_1$-measurable and $snd\restrict{A}$ is $\A-\A_2$-measurable.
\end{lemma}

\subsection{Measures and Probabilities}

Now that we have defined what sets can be measured, we can define what it means to measure them.

\begin{definition}[Measure]
A mapping $\mu \in \powerset~X \pto [0,\infty)$ is a \keyword{measure} if
\begin{itemize}
	\item $domain~\mu$ is a $\sigma$-algebra on $X$.
	\item $\mu~\emptyset = 0$.
	\item For all $\A' \subseteq \A$ such that $|\A'| \leq \omega$, $\sum\limits_{A \in \A'} (\mu~A) = \mu~(\U \A')$.
\end{itemize}
\end{definition}

XXX: Probabilities of output sets are preimage measures: if $f \in A \pto B$ is $\A-\B$-measurable and $\P \in \A \to [0,1]$, then
\begin{equation}
	\P~(preimage~f~B)
\end{equation}
is the probability of $B$.

XXX: more explanation, and an example

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Bottom Arrow}

XXX: motivation:
\begin{itemize}
	\item derive preimage arrow from something simple and obviously correct
	\item eventually define functions that may diverge using this arrow; use derivation to do the same with the preimage arrow
	\item will be implemented to run programs on domain samples
\end{itemize}

XXX: Fig.~\ref{fig:bottom-arrow-defs} defines the bottom arrow...

\begin{figure*}[t]\centering
\begin{align*}
\begin{aligned}
	&\begin{aligned}
		&\arrbot : (X \tto Y_\bot) \tto (X \tto Y_\bot) \\
		&\arrbot~f \ := \ f
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}
		&\compbot : (X \tto Y_\bot) \tto (Y \tto Z_\bot) \tto (X \tto Z_\bot) \\
		&\compbot~f_1~f_2~x \ := \ if~(f_1~x = \bot)~\bot~(f_2~(f_1~x))
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}
		&\pairbot : (X \tto Y_\bot) \tto (X \tto Z_\bot) \tto (X \tto \pair{Y,Z}_\bot) \\
		&\pairbot~f_2~f_2~x \ := \ if~(f_1~x = \bot \bor f_2~x = \bot)~\bot~{\pair{f_1~x,f_2~x}}
	\end{aligned}
\end{aligned}
&\tab\tab
\begin{aligned}
	&\begin{aligned}
		&\ifbot : ~(X \tto Bool_\bot) \tto (1 \tto (X \tto Y_\bot)) \tto (1 \tto (X \tto Y_\bot)) \tto (X \tto Y_\bot) \\
		&\ifbot~f_1~f_2~f_3~x \ := \
			\lzfccase{f_1~x}{true & f_2~0~x \\ false & f_3~0~x \\ else & \bot}
	\end{aligned}
\end{aligned}
\end{align*}
\hrule
\caption{Bottom arrow definitions.}
\label{fig:bottom-arrow-defs}
\end{figure*}

XXX: the standard Kleisli conversion of the Maybe monad (using a $\bot$ instead of Just and Maybe), simplified; arrow laws therefore hold (XXX: check terminology)

XXX: point out that $\ifbot$ receives thunks, and remind readers that $1 = \set{0}$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Deriving the Mapping Arrow}

XXX: intermediate step between the bottom and preimage arrows; will not be implemented (no approximation will be implemented, either); computations are in terms of mappings, on which we can apply theorems from measure theory directly

XXX: the type of mapping arrow computations
\begin{equation}
	X \mapto Y \ ::= \ Set~X \tto (X \pto Y)
\end{equation}
XXX: notice $X \pto Y$, not $X \pto Y_\bot$

XXX: motivate removal of bottom

Lifting a bottom arrow computation $f : X \tto Y_\bot$ to the mapping arrow requires restricting $f$'s domain to a subset of $X$ for which $f$ does not return $\bot$.
It is helpful to have a standalone function $domain_\bot$ that computes such domains, so we define that first, and $\arrmap$ in terms of $domain_\bot$:
\begin{align}
	&\begin{aligned}
		&domain_\bot : (X \tto Y_\bot) \tto Set~X \tto Set~X \\
		&domain_\bot~f~A \ := \ preimage~f\restrict{A}~((image~f~A) \w \set{\bot})
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		&\arrmap : (X \tto Y_\bot) \tto (X \mapto Y) \\
		&\arrmap~f~A \ := \ \lzfclet{A' & domain_\bot~f~A}{f\restrict{A'}}
	\end{aligned}
\end{align}

XXX: the default equality relation, which for \lzfclang terms is alpha equivalence of reduced terms, will not do; need something more extensional

\begin{definition}[Mapping arrow equivalence]
Two mapping arrow computations $g_1 : X \mapto Y$ and $g_2 : X \mapto Y$ are equivalent, written $g_1 \eqmap g_2$, when $g_1~A \equiv g_2~A$ for all $A \subseteq X$.
\end{definition}


\subsection{Natural Transformation}

The clearest way to ensure that mapping arrow computations mean what we think they mean is to derive each combinator in a way that makes $\arrmap$ into a \keyword{natural transformation}: a transformation that maintains the overall structure of the computations.
As a bonus, the arrow laws naturally hold.

Formally, for $\arrmap$ to be a natural transformation, we require the following identities to hold:
\begin{align}
	&\begin{aligned}
		\arrmap~(\pairbot~f_1~f_2) \ \eqmap \ \pairmap~(\arrmap~f_1)~(\arrmap~f_2)
	\label{eqn:arrmap-distributes-over-pair}
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		\arrmap~(\compbot~f_1~f_2) \ \eqmap \ \compmap~(\arrmap~f_1)~(\arrmap~f_2)
	\label{eqn:arrmap-distributes-over-comp}
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		&\arrmap~(\ifbot~f_1~f_2~f_3) \ \eqmap \ \\
		&\tab\ifmap~(\arrmap~f_1)~(\fun{0}{\arrmap~(f_2~0)})~(\fun{0}{\arrmap~(f_3~0)})
	\label{eqn:arrmap-distributes-over-if}
	\end{aligned}
\end{align}
i.e. $\arrmap$ must distribute over bottom arrow computations.

Fig.~\ref{fig:mapping-arrow-defs} shows the final result of deriving the mapping arrow as a natural transformation from the bottom arrow.

\begin{figure*}[t]\centering
\begin{align*}
\begin{aligned}
	&\begin{aligned}
		X \mapto Y \ ::= \ Set~X \tto (X \pto Y)
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}
		&\arrmap : (X \tto Y_\bot) \tto (X \mapto Y) \\
		&\arrmap~f~A \ := \ \lzfclet{A' & domain_\bot~f~A}{f\restrict{A'}}
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}
		&\compmap : (X \mapto Y) \tto (Y \mapto Z) \tto (X \mapto Z) \\
		&\compmap~g_1~g_2~A \ := \ 
			\lzfclet{
				g_1' & g_1~A \\
				g_2' & g_2~(range~g_1')
			}{g_2' \circ\map g_1'}
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}
		&\pairmap : (X \mapto Y) \tto (X \mapto Z) \tto (X \mapto \pair{Y,Z}) \\
		&\pairmap~g_1~g_2~A \ := \ \pair{g_1~A,g_2~A}\map
	\end{aligned}
\end{aligned}
&\tab\tab\tab
\begin{aligned}
	&\begin{aligned}
		&\ifmap : (X \mapto Bool) \tto (1 \tto (X \mapto Y)) \tto (1 \tto (X \mapto Y)) \tto (X \mapto Y) \\
		&\lzfcsplit{
			&\ifmap~g_1~g_2~g_3~A \ := \ \\
			&\tab\lzfclet{
				g_1' & g_1~A \\
				g_2' & lazy\map~(g_2~0)~(preimage~g_1'~\set{true}) \\
				g_3' & lazy\map~(g_3~0)~(preimage~g_1'~\set{false})
			}{g_2' \uplus\map g_3'}
		}
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}
		&domain_\bot : (X \tto Y_\bot) \tto Set~X \tto Set~X \\
		&domain_\bot~f~A \ := \ preimage~f\restrict{A}~((image~f~A) \w \set{\bot})
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}
		&lazy\map : (X \mapto Y) \tto (X \mapto Y) \\
		&lazy\map~g~A \ := \ if~(A = \emptyset)~\emptyset~(g~A)
	\end{aligned}
\end{aligned}
\end{align*}
\hrule
\caption{Mapping arrow definitions.}
\label{fig:mapping-arrow-defs}
\end{figure*}

\begin{theorem}[mapping arrow correctness]
$\arrmap$ is a natural transformation from the bottom arrow.
\end{theorem}
\begin{proof}
By structural induction; cases follow.
\end{proof}

Each case---pairing, composition, conditional---is proved by construction, yielding an implementation.

\subsection{Case: Pairing}

Starting with the left-hand side of~\eqref{eqn:arrmap-distributes-over-pair}, we first expand definitions. For any $A : Set~X$,
\begin{align*}
	&\arrmap~(\pairbot~f_1~f_2)~A
\\
	&\tab \equiv \ \arrmap~(\fun{x}{if~(f_1~x = \bot \bor f_2~x = \bot)~\bot~{\pair{f_1~x,f_2~x}}})~A
\\
	&\tab \equiv \ 
		\lzfclet{
			f & \fun{x}{if~(f_1~x = \bot \bor f_2~x = \bot)~\bot~{\pair{f_1~x,f_2~x}}} \\
			A' & domain_\bot~f~A
		}{f\restrict{A'}}
\numberthis
\end{align*}
Next, we replace the definition of $A'$ with one that does not depend on $f$, and rewrite in terms of $\arrmap~f_1$ and $\arrmap~f_2$:
\begin{align*}
	&\arrmap~(\pairbot~f_1~f_2)~A
\\
	&\tab \equiv \ 
		\lzfclet{
			A_1 & (domain_\bot~f_1~A) \\
			A_2 & (domain_\bot~f_2~A) \\
			A' & A_1 \i A_2
		}{\fun{x \in A'}{\pair{f_1~x,f_2~x}}}
\\
	&\tab \equiv \ 
		\lzfclet{
			g_1 & \arrmap~f_1~A \\
			g_2 & \arrmap~f_2~A \\
			A' & (domain~g_1) \i (domain~g_2)
		}{\fun{x \in A'}{\pair{g_1~x,g_2~x}}}
\\
	&\tab \equiv \ \pair{\arrmap~f_1~A, \arrmap~f_2~A}\map
\numberthis
\end{align*}
Substituting $g_1$ for $\arrmap~f_1$ and $g_2$ for $\arrmap~f_2$ in the last equality gives the definition for $\pairmap$:
\begin{equation}
\begin{aligned}
	&\pairmap : (X \mapto Y) \tto (X \mapto Z) \tto (X \mapto \pair{Y,Z}) \\
	&\pairmap~g_1~g_2~A \ := \ \pair{g_1~A,g_2~A}\map
\end{aligned}
\end{equation}
Thus, $\arrmap$ distributes over $\pairbot$ by construction.

\subsection{Case: Composition}

The derivation of $\compmap$ is similar to that of $\pairmap$ but a little more involved.

XXX: include it?

\subsection{Case: Conditional}

The derivation of $\ifmap$ needs some care to maintain laziness of conditional branches in the presence of recursion.

We will use as an example the following bottom arrow computation, which returns $true$ when applied to $true$ and diverges on $false$:
\begin{equation}
	halts@on@true_\bot \ := \ \ifbot~id~(\fun{0}{id})~(\fun{0}{halts@on@true_\bot})
\end{equation}
Its natural transformation to the mapping arrow should diverge only if applied to a set containing $false$.

Starting with the left-hand-side of~\eqref{eqn:arrmap-distributes-over-if}, we expand definitions, and simplify $f$ by restricting it to a domain for which $f_1~x$ cannot be $\bot$:
\begin{align*}
	&\arrmap~(\ifbot~f_1~f_2~f_3)~A \\
	&\tab \equiv \ 
		\lzfclet{
			f & \fun{x}{\lzfccase{f_1~x}{true & f_2~0~x \\ false & f_3~0~x \\ else & \bot}} \\
			A' & domain_\bot~f~A
		}{f\restrict{A'}} \\
	&\tab \equiv \ 
		\lzfclet{
			A_2 & preimage~f_1\restrict{A}~\set{true} \\
			A_3 & preimage~f_1\restrict{A}~\set{false} \\
			f & \fun{x}{if~(f_1~x)~(f_2~0~x)~(f_3~0~x)} \\
			A' & domain_\bot~f~(A_2 \u A_3)
		}{f\restrict{A'}}
\numberthis
\end{align*}
It is tempting at this point to finish by simply converting bottom arrow computations to the mapping arrow; i.e.
\begin{align*}
	&\arrmap~(\ifbot~f_1~f_2~f_3)~A \\
	&\tab \equiv \ 
		\lzfclet{
			g_1 & \arrmap~f_1~A \\
			A_2 & preimage~g_1~\set{true} \\
			A_3 & preimage~g_1~\set{false} \\
			g_2 & \arrmap~(f_2~0)~A_2 \\
			g_3 & \arrmap~(f_3~0)~A_3 \\
			A' & (domain~g_2) \u (domain~g_3)
		}{\fun{x \in A'}{if~(g_1~x)~(g_2~x)~(g_3~x)}}
\numberthis
\end{align*}
This is close to correct.
Unfortunately, for $halts@on@true_\bot$, computing $g_3 := \arrmap~(f_3~0)~A_3$ always diverges.
Wrapping the branch computations $g_2$ and $g_3$ in thunks will not help because $A'$ is computed from their domains.

Note that the ``true'' branch needs to be taken only if $A_2$ is nonempty; similarly for the ``false'' branch and $A_3$.
Further, applying a mapping arrow computation to $\emptyset$ should always yield the empty mapping $\emptyset$.
We can therefore maintain laziness in conditional branches by applying $\arrmap~(f_2~0)$ and $\arrmap~(f_3~0)$ only to nonempty sets, using
\begin{equation}
\begin{aligned}
	&lazy\map : (X \mapto Y) \tto (X \mapto Y) \\
	&lazy\map~f~A \ := \ if~(A = \emptyset)~\emptyset~(f~A)
\end{aligned}
\end{equation}
In terms of $lazy\map$, we have
\begin{align*}
	&\arrmap~(\ifbot~f_1~f_2~f_3)~A \numberthis
\\
	&\tab \equiv \ 
	\lzfclet{
		g_1 & \arrmap~f_1~A \\
		g_2 & lazy\map~(\arrmap~(f_2~0))~(preimage~g_1~\set{true}) \\
		g_3 & lazy\map~(\arrmap~(f_3~0))~(preimage~g_1~\set{false}) \\
		A' & (domain~g_2) \u (domain~g_3)
	}{\fun{x \in A'}{if~(g_1~x)~(g_2~x)~(g_3~x)}}
\\
	&\tab \equiv \
	\lzfclet{
		g_1 & \arrmap~f_1~A \\
		g_2 & lazy\map~(\arrmap~(f_2~0))~(preimage~g_1~\set{true}) \\
		g_3 & lazy\map~(\arrmap~(f_3~0))~(preimage~g_1~\set{false})
	}{g_2 \uplus\map g_3}
\end{align*}
For $halts@on@true_\bot$, $lazy\map~(\arrmap~(f_3~0))~A_3$ does not diverge when $A_3$ is empty.

Substituting $g_1$ for $\arrmap~f_1$, $g_2~0$ for $\arrmap~(f_2~0)$, and $g_3~0$ for $\arrmap~(f_3~0)$ in the last equality gives the definition for $\ifmap$.

\subsection{Super-Saver Theorems}

The following two theorems are easy consequences of the fact that $\arrmap$ is a natural transformation.

\begin{corollary}
$\arrmap$, $\pairmap$ and $\compmap$ define an arrow.
\end{corollary}

\begin{corollary}
Let $f : X \tto Y_\bot$ and $g : X \mapto Y$ such that $g \ \eqmap \ \arrmap~f$.
Then for all $A \subseteq X$, $g~A$ diverges if and only if there exists an $x \in A$ for which $f~x$ diverges.
\end{corollary}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Preimage Mappings}

On a computer, we will not often have the luxury of testing each function input to see whether it belongs in a preimage set.
Even for finite domains, doing so is often intractable.

If we wish to compute with abstract, infinite sets in the language implementation, we will need its semantics defined so that removing all point computations is easy.
Therefore, in the preimage arrow, we will confine computation on points to \mykeyword{preimage mappings}, for which application is like applying $preimage$ to a mapping.
The function space is constructed by
\begin{equation}
	X \prepto Y \ := \ \powerset~Y \pto \powerset~X
\end{equation}
XXX: convert a mapping to a preimage mapping:
\begin{equation}
\begin{aligned}
	&pre : (X \pto Y) \tto Set~(Set~Y) \tto (X \prepto Y) \\
	&pre~g~\B \ := \ \fun{B \in \B}{preimage~g~B}
\end{aligned}
\end{equation}
Note that $\B$ is not necessarily a $\sigma$-algebra; in particular, it may be a generating family such as $\B_1 \boxtimes \B_2$.

While preimages can be computed for any subset of a mapping's \emph{codomain}, preimage mappings are usually defined on smaller sets, such as a mapping's \emph{range}.
We need a function to compute preimages of sub-codomains, so
\begin{equation}
\begin{aligned}
	&pre@ap : (X \prepto Y) \tto Set~Y \tto Set~X \\
	&pre@ap~h~B \ := \ h~(B \i \U(domain~h))
\end{aligned}
\end{equation}
The necessary property here is that using $pre@ap$ to compute preimages is the same as computing them from a mapping using $preimage$:
\begin{theorem}[$pre@ap$ computes preimages]
Let
\begin{equation}
\begin{array}{@{}r@{}l@{}}
	&g \in X \pto Y, \text{ with $\B$ a $\sigma$-algebra on $Y$} \\
	&Y' \text{ a set such that $(range~g) \subseteq Y' \subseteq Y$} \\
	&\B' := trace~\B~Y'
\end{array}
\end{equation}
Then for all $B \in \B$, $pre@ap~(pre~g~\B')~B = preimage~g~B$.
\label{thm:pre-like-preimage}
\end{theorem}
\begin{proof}
Expand the definitions of $pre@ap$ and $pre$, and use $\U(domain~h) = Y'$ and $B \i Y' \in \B'$ (by definition of $trace$):
\begin{align*}
	pre@ap~(pre~g~\B)~B 
		&\ = \ 
			\lzfclet{
				h & \fun{B \in \B'}{preimage~g~B}
			}{h~(B \i \U(domain~h))}
\\
		&\ = \ 
			\lzfclet{
				h & \fun{B \in \B'}{preimage~g~B}
			}{h~(B \i Y')}
\\
		&\ = \ preimage~g~(B \i Y')
\\
		&\ = \ preimage~g~B
\end{align*}
\end{proof}

\subsection{Generated Preimage Mappings}

XXX: for pairing, will need to define preimage mappings for a generating family, then close the domain (and thus the range) under $\sigma$-algebra operations

XXX: proceeds just like generating $\sigma$-algebras: define a single, monotone operation:
\begin{align}
	&\begin{aligned}
		&pre@comps : (X \prepto Y) \tto (X \prepto Y) \\
		&\lzfcsplit{
			&pre@comps~h \ := \ \\
			&\tab\lzfclet{
					\B & domain~h
				}{\setb{\pair{B_1 \w B_2,(h~B_1) \w (h~B_2)}}{B_1,B_2 \in \B}}
		}
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		&pre@unions : (X \prepto Y) \tto (X \prepto Y) \\
		&\lzfcsplit{
			&pre@unions~h \ := \ \\
			&\tab\lzfclet{
					\B & domain~h
				}{\setb{\pair{\U \B', \U (image~h~\B')}}{\B' \subseteq \B \band |\B'| \leq \omega}}
		}
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		&pre@ops : (X \prepto Y) \tto (X \prepto Y) \\
		&pre@ops~h \ := \ \set{\pair{\emptyset,\emptyset}} \u (pre@comps~h) \u (pre@unions~h)
	\end{aligned}
\end{align}
XXX: then apply $close$ to it with a sufficient number of iterations:
\begin{equation}
\begin{aligned}
	&pre@close : (X \prepto Y) \tto (X \prepto Y) \\
	&pre@close \ := \ close~pre@ops~\omega_1
\end{aligned}
\end{equation}

XXX: central fact: closing a preimage mapping defined for a generating family is equivalent to defining that preimage mapping for the generated $\sigma$-algebra
\begin{theorem}[$pre@close$ distributes over $pre$]
Let $f \in X \pto Y$ and $\B$ a generating family for $Y$.
Then $pre@close~(pre~f~\B) = pre~f~(\sigma@close~\B)$.
\label{thm:close-distributes-over-pre}
\end{theorem}
\begin{proof}
By transfinite induction, using: the preimage of $\emptyset$ under any function is $\emptyset$, and preimages distribute over complements and unions.
\end{proof}

\subsection{Preimage Mapping Pairing}

XXX: moar wurds in this section

\begin{equation}
\begin{aligned}
	&\pair{\cdot,\cdot}\pre : (X \prepto Y) \tto (X \prepto Z) \tto (X \prepto Y \times Z) \\
	&\pair{h_1,h_2}\pre \ := \ 
	\lzfclet{
			\B & (domain~h_1) \boxtimes (domain~h_2) \\
			h & \fun{B_1 \times B_2 \in \B}{(h_1~B_1) \i (h_2~B_2)}
		}{pre@close~h}
\end{aligned}
\end{equation}

\begin{lemma}[$preimage$ distributes over pairing]
Let $g_1 \in X \pto Y$ and $g_2 \in X \pto Z$.
Then for all $B_1 \subseteq Y$ and $B_2 \subseteq Z$, $preimage~\pair{g_1,g_2}\map~(B_1 \times B_2) = (preimage~g_1~B_1) \i (preimage~g_2~B_2)$.
\label{lem:preimage-under-pairing}
\end{lemma}

\begin{theorem}[$trace$ distributes over $(\boxtimes)$ and $(\times)$]
For any families $\A_1$ and $\A_2$, $trace~(\A_1 \boxtimes \A_2)~(A_1 \times A_2) = (trace~\A_1~A_1) \boxtimes (trace~\A_2~A_2)$.
\label{thm:trace-distributes-over-boxtimes-and-times}
\end{theorem}
\begin{proof}
Expand $(\boxtimes)$ and $trace$, $(\i)$ distributes over $(\times)$, rewrite in terms of $(\boxtimes)$, and rewrite in terms of $trace$.
\begin{align*}
	&trace~(\A_1 \boxtimes \A_2)~(A_1 \times A_2)
\\
	&\tab = \ \setb{(A_1 \times A_2) \i (A_1' \times A_2')}{A_1' \in \A_1, A_2' \in \A_2}
\\
	&\tab = \ \setb{(A_1 \i A_1') \times (A_2 \i A_2')}{A_1' \in \A_1, A_2' \in \A_2}
\\
	&\tab = \ \setb{A_1 \i A_1'}{A_1' \in \A_1} \boxtimes \setb{A_2 \i A_2'}{A_2' \in \A_2}
\\
	&\tab = \ (trace~\A_1~A_1) \boxtimes (trace~\A_2~A_2)
\end{align*}
\end{proof}

\begin{theorem}[$trace$ distributes over $(\otimes)$ and $(\times)$]
For any $\sigma$-algebras $\A_1$ and $\A_2$, $trace~(\A_1 \otimes \A_2)~(A_1 \times A_2) = (trace~\A_1~A_1) \otimes (trace~\A_2~A_2)$.
\label{thm:trace-distributes-over-otimes-and-times}
\end{theorem}
\begin{proof}
Expand $(\otimes)$, apply Lemma~\ref{lem:close-distributes-over-trace}, apply Theorem~\ref{thm:trace-distributes-over-boxtimes-and-times}, and rewrite in terms of $(\otimes)$.
\begin{align*}
	&trace~(\A_1 \otimes \A_2)~(A_1 \times A_2)
\\
	&\tab = \ trace~(\sigma@close~(\A_1 \boxtimes \A_2))~(A_1 \times A_2)
\\
	&\tab = \ \sigma@close~(trace~(\A_1 \boxtimes \A_2)~(A_1 \times A_2))
\\
	&\tab = \ \sigma@close~((trace~\A_1~A_1) \boxtimes (trace~\A_2~A_2))
\\
	&\tab = \ (trace~\A_1~A_1) \otimes (trace~\A_2~A_2)
\end{align*}
\end{proof}

\begin{theorem}[$pre@ap$ of $\pair{\cdot,\cdot}\pre$ computes preimages]
Let
\begin{equation}
\begin{array}[t]{@{}r@{}l@{}}
	&g_1 \in X \pto Y, \text{ with $\B_1$ a $\sigma$-algebra on $Y$} \\
	&\B_1' := trace~\B_1~(range~g_1) \\
	&h_1 := pre~g_1~\B_1' \\
	&g_2 \in X \pto Z, \text{ with $\B_2$ a $\sigma$-algebra on $Z$} \\
	&\B_2' := trace~\B_2~(range~g_2) \\
	&h_2 := pre~g_2~\B_2
\end{array}
\end{equation}
Then for all pair sets $B \in \B_1 \otimes \B_2$, $pre@ap~\pair{h_1,h_2}\pre~B = preimage~\pair{g_1,g_2}\map~B$.
\label{thm:preimage-mapping-pairing}
\end{theorem}
\begin{proof}
Expand definitions, substitute $h_1$ and $h_2$, expand definition of $pre$, apply Lemma~\ref{lem:preimage-under-pairing}, rewrite in terms of $pre$, apply Theorem~\ref{thm:close-distributes-over-pre}, apply Theorem~\ref{thm:trace-distributes-over-otimes-and-times}, and apply Theorem~\ref{thm:pre-like-preimage}.
\begin{align*}
	&pre@ap~\pair{h_1, h_2}\pre~B 
\\
	&\tab = \ 
		\lzfclet{
			\B' & (domain~h_1) \boxtimes (domain~h_2) \\
			h & \fun{B_1 \times B_2 \in \B'}{(h_1~B_1) \i (h_2~B_2)} \\
		}{pre@ap~(pre@close~h)~B}
\\
	&\tab = \ 
		\lzfclet{
			\B' & \B_1' \boxtimes \B_2' \\
			h & \lzfcsplit{&\fun{B_1 \times B_2 \in \B'} \\ &\tab (pre~g_1~\B_1'~B_1) \i (pre~g_2~\B_2'~B_2)} \\
		}{pre@ap~(pre@close~h)~B}
\\
	&\tab = \ 
		\lzfclet{
			\B' & \B_1' \boxtimes \B_2' \\
			h & \lzfcsplit{&\fun{B_1 \times B_2 \in \B'} \\ &\tab (preimage~g_1~B_1) \i (preimage~g_2~B_2)} \\
		}{pre@ap~(pre@close~h)~B}
\\
	&\tab = \ 
		\lzfclet{
			\B' & \B_1' \boxtimes \B_2' \\
			h & \fun{B \in \B'}{preimage~\pair{g_1,g_2}\map~B} \\
		}{pre@ap~(pre@close~h)~B}
\\
	&\tab = \ 
		\lzfclet{
			\B' & \B_1' \boxtimes \B_2'
		}{pre@ap~(pre@close~(pre~\pair{g_1,g_2}\map~\B'))~B}
\\
	&\tab = \ 
		\lzfclet{
			\B' & \B_1' \otimes \B_2'
		}{pre@ap~(pre~\pair{g_1,g_2}\map~\B')~B}
\\
	&\tab = \ 
		\lzfclet{
			\B' & trace~\B~((range~g_1) \times (range~g_2))
		}{pre@ap~(pre~\pair{g_1,g_2}\map~\B')~B}
\\
	&\tab = \ preimage~\pair{g_1,g_2}\map~B
\end{align*}
\end{proof}

\subsection{Preimage Mapping Composition}

XXX: moar wurds in this section

\begin{equation}
\begin{aligned}
	&(\circ\pre) : (Y \prepto Z) \tto (X \prepto Y) \tto (X \prepto Z) \\
	&h_2 \circ\pre h_1 \ := \ \lzfclet{\C & domain~h_2}{\fun{C \in \C}{pre@ap~h_1~(h_2~C)}}
\end{aligned}
\end{equation}

\begin{lemma}[preimages under composition]
Let $g_1 \in X \pto Y$ and $g_2 \in Y \pto Z$.
Then for all $C \subseteq Z$, $preimage~(g_2 \circ\map g_1)~C = preimage~g_1~(preimage~g_2~C)$.
\label{lem:preimage-under-composition}
\end{lemma}

\begin{theorem}[preimage mapping composition]
Let
\begin{equation}
\begin{array}[t]{@{}r@{}l@{}}
	&g_2 \in Y \pto Z, \text{ with $\C$ a $\sigma$-algebra on $Z$} \\
	&\C' := \sigma@trace~\C~(range~g_2) \\
	&h_2 := pre~g_2~\C' \\
	&g_1 \in X \pto Y \\
	&\B' := \sigma@trace~(range~h_2)~(range~g_1) \\
	&h_1 := pre~g_1~\B' \\
\end{array}
\end{equation}
Then for all $C \in \C$, $pre@ap~(h_2 \circ\pre h_1)~C = preimage~(g_2 \circ\map g_1)~C$.
\label{thm:preimage-mapping-composition}
\end{theorem}
\begin{proof}
Expand definitions, apply Theorem~\ref{thm:pre-like-preimage}, expand $h$, rewrite in terms of $pre@ap$, apply Theorem~\ref{thm:pre-like-preimage}, and apply Lemma~\ref{lem:preimage-under-composition}.
\begin{align*}
	&pre@ap~(h_2 \circ\pre h_1)~C
\\
	&\tab = \ 
		\lzfclet{
			h & \fun{C \in \C'} pre@ap~(pre~g_1~\B')~((pre~g_2~\C')~C)
		}{h~(C \i \U(domain~h))}
\\
	&\tab = \ 
		\lzfclet{
			h & \fun{C \in \C'} preimage~g_1~((pre~g_2~\C')~C)
		}{h~(C \i \U\C')}
\\
	&\tab = \ preimage~g_1~((pre~g_2~\C')~(C \i \U\C'))
\\
	&\tab = \ preimage~g_1~(pre@ap~(pre~g_2~\C')~C)
\\
	&\tab = \ preimage~g_1~(preimage~g_2~C)
\\
	&\tab = \ preimage~(g_2 \circ\map g_1)~C
\numberthis
\end{align*}
\end{proof}

\subsection{Piecewise Preimage Mappings}

XXX: moar wurds in this section

\begin{equation}
\begin{aligned}
	&(\uplus\pre) : (X \prepto Y) \tto (X \prepto Y) \tto (X \prepto Y)
\\
	&\lzfcsplit{
		&h_1 \uplus\pre h_2 \ := \ \\
		&\tab\lzfclet{
				\B & (domain~h_1) \u (domain~h_2) \\
				h & \fun{B \in \B}{(pre@ap~h_1~B) \uplus (pre@ap~h_2~B)}
			}{pre@close~h}
	}
\end{aligned}
\end{equation}

\begin{lemma}[preimages under piecewise mappings]
Let $g_1 \in X \pto Y$ and $g_2 \in X \pto Y$ have disjoint domains.
Then for all $B \subseteq Y$, $preimage~(g_1 \uplus\map g_2)~B = (preimage~g_1~B) \uplus (preimage~g_2~B)$.
\label{lem:preimage-under-piecewise}
\end{lemma}


\begin{theorem}[piecewise preimage mappings]
Let $g_1 \in X \pto Y$ and $g_2 \in X \pto Y$ have disjoint domains.
Let $\B'$ be a $\sigma$-algebra on $Y$, $\B_1 := \sigma@trace~\B'~(range~g_1)$ and $\B_2 := \sigma@trace~\B'~(range~g_2)$.
Let $h_1 := pre~g_1~\B_1$ and $h_2 := pre~g_2~\B_2$.
Then for all $B \in \B'$, $pre@ap~(h_1 \uplus\pre h_2)~B = preimage~(g_1 \uplus\map g_2)~B$.
\label{thm:piecewise-preimage-mappings}
\end{theorem}
\begin{proof}
Expand definitions, substitute $h_1$ and $h_2$, apply Theorem~\ref{thm:pre-like-preimage}, apply Lemma~\ref{lem:preimage-under-piecewise}, rewrite in terms of $pre$, apply Theorem~\ref{thm:close-distributes-over-pre}, and rewrite in terms of $(\oplus)$:
\begin{align*}
	&pre@ap~(h_1 \uplus\pre h_2)~B
\\
	&\tab = \ 
		\lzfclet{
			\B & (domain~h_1) \u (domain~h_2) \\
			h & \fun{B \in \B}{(pre@ap~h_1~B) \uplus (pre@ap~h_2~B)}
		}{pre@ap~(pre@close~h)~B}
\\
	&\tab = \
		\lzfclet{
			\B & \B_1 \u \B_2 \\
			h & \fun{B \in \B}{\lzfcsplit{&(pre@ap~(pre~g_1~\B_1)~B)\ \uplus \\ &(pre@ap~(pre~g_2~\B_2)~B)}}
		}{pre@ap~(pre@close~h)~B}
\\
	&\tab = \
		\lzfclet{
			\B & \B_1 \u \B_2 \\
			h & \fun{B \in \B}{\lzfcsplit{&(preimage~g_1~B)\ \uplus \\ &(preimage~g_2~B)}}
		}{pre@ap~(pre@close~h)~B}
\\
	&\tab = \
		\lzfclet{
			\B & \B_1 \u \B_2 \\
			h & \fun{B \in \B}{preimage~(g_1 \uplus\map g_2)~B}
		}{pre@ap~(pre@close~h)~B}
\\
	&\tab = \
		\lzfclet{
			\B & \B_1 \u \B_2
		}{pre@ap~(pre@close~(pre~(g_1 \uplus\map g_2)~\B))~B}
\\
	&\tab = \
		\lzfclet{
			\B & \B_1 \u \B_2
		}{pre@ap~(pre~(g_1 \uplus\map g_2)~(\sigma@close~\B))~B}
\end{align*}
Finally, noting that $\sigma@trace~\B'~((range~g_1) \u (range~g_2)) \subseteq \sigma@close~(\B_1 \u \B_2)$, apply Theorem~\ref{thm:pre-like-preimage}.
\end{proof}



\section{The Universe}

XXX: to define standard $\sigma$-algebras, we need a universal set $\Univ$ and a universal $\sigma$-algebra $\Un$

XXX: for any subset $A \subseteq \Univ$, $\sigma$ returns the \mykeyword{standard $\sigma$-algebra} for $A$
\begin{equation}
\begin{aligned}
	&\sigma : Set~X \tto Set~(Set~X) \\
	&\sigma~A \ := \ trace~\Un~A
\end{aligned}
\end{equation}

XXX: requirements: $\set{true}$ and $\set{false}$ must be measurable, must be closed under $(\otimes)$


\section{Deriving the Preimage Arrow}

XXX: intro

\begin{equation}
	X \preto Y \ ::= \ Set~X \tto (X \prepto Y)
\end{equation}

\begin{equation}
\begin{aligned}
	&\arrpre : (X \mapto Y) \tto (X \preto Y) \\
	&\arrpre~g~A \ := \ 
		\lzfclet{
			g' & g~A \\
			\B' & \sigma~(range~g')
		}{pre~g'~\B'}
\end{aligned}
\end{equation}

\begin{definition}[Preimage arrow equivalence]
Two preimage arrow computations $h_1 : X \preto Y$ and $h_2 : X \preto Y$ are equivalent, written $h_1 \eqpre h_2$, when 
$pre@ap~(h_1~A)~B \equiv pre@ap~(h_2~A)~B$ for any $A \subseteq X$ and $B \in \sigma~Y$.
\end{definition}

\subsection{Natural Transformation}

XXX: ensuring $\arrpre$ is a natural transformation from the mapping arrow...

Formally, for $\arrpre$ to be a natural transformation,
\begin{align}
	&\begin{aligned}
		\arrpre~(\pairmap~g_1~g_2) \ \eqpre \ \pairpre~(\arrpre~g_1)~(\arrpre~g_2)
	\label{eqn:arrpre-distributes-over-pairmap}
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		\arrpre~(\compmap~g_1~g_2) \ \eqpre \ \comppre~(\arrpre~g_1)~(\arrpre~g_2)
	\label{eqn:arrpre-distributes-over-compmap}
	\end{aligned} \\
\nonumber \\[-6pt]
	&\begin{aligned}
		&\arrpre~(\ifmap~g_1~g_2~g_3) \ \eqpre \ \\
		&\tab\ifpre~(\arrpre~g_1)~(\fun{0}{\arrpre~(g_2~0)})~(\fun{0}{\arrpre~(g_3~0)})
	\label{eqn:arrpre-distributes-over-ifmap}
	\end{aligned}
\end{align}
i.e. $\arrpre$ must distribute over mapping arrow computations.

Fig.~\ref{fig:preimage-arrow-defs} shows the final result of deriving the preimage arrow as a natural transformation from the mapping arrow.

\begin{figure*}[t]\centering
\begin{align*}
\begin{aligned}
	&\begin{aligned}
		&X \preto Y ::= Set~X \tto (X \prepto Y)
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}
		&\arrpre : (X \mapto Y) \tto (X \preto Y) \\
		&\arrpre~g~A \ := \ \lzfclet{g' & g~A \\ \B & \sigma~(range~g')}{pre~g'~\B}
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}
		&\comppre : (X \preto Y) \tto (Y \preto Z) \tto (X \preto Z) \\
		&\comppre~h_1~h_2~A \ := \ 
			\lzfclet{
				h_1' & h_1~A \\
				h_2' & h_2~(\U (domain~h_1'))
			}{h_2 \circ\pre h_1}
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}
		&\pairpre : (X \preto Y) \tto (X \preto Z) \tto (X \preto Y \times Z) \\
		&\pairpre~h_1~h_2~A \ := \ \pair{h_1~A,h_2~A}\pre
	\end{aligned}
\end{aligned}
&\tab\tab\tab
\begin{aligned}
	&\begin{aligned}
		&\ifpre: (X \preto Bool) \tto (1 \tto (X \preto Y)) \tto (1 \tto (X \preto Y)) \tto (X \preto Y) \\
		&\lzfcsplit{
			&\ifpre~h_1~h_2~h_3~A \ := \ \\
			&\lzfclet{
				h_1' & h_1~A \\
				h_2' & lazy\pre~(h_2~0)~(pre@ap~h_1'~\set{true}) \\
				h_3' & lazy\pre~(h_3~0)~(pre@ap~h_1'~\set{false})
			}{h_2' \uplus\pre h_3'}
		}
	\end{aligned} \\
\\[-6pt]
	&\begin{aligned}
		&lazy\pre : (X \preto Y) \tto (X \preto Y) \\
		&lazy\pre~h~A \ := \ if~(A = \emptyset)~(\fun{\emptyset}{\emptyset})~(h~A)
	\end{aligned}
\end{aligned}
\end{align*}
\hrule
\caption{Preimage arrow definitions.}
\label{fig:preimage-arrow-defs}
\end{figure*}

\begin{theorem}[preimage arrow correctness]
$\arrpre$ is a natural transformation from the mapping arrow.
\end{theorem}
\begin{proof}
By structural induction; cases follow.
\end{proof}

\subsection{Case: Pairing}

Starting with the left-hand side of~\eqref{eqn:arrpre-distributes-over-pairmap}, we expand definitions and apply Theorem~\ref{thm:pre-like-preimage} with $\B' = trace~\B~(range~g')$ and $\B = trace~\Un~(Y \times Z)$:
\begin{align*}
	&pre@ap~(\arrpre~(\pairmap~g_1~g_2)~A)~B
\\
	&\tab \equiv \ 
		\lzfclet{
			g' & \pair{g_1~A, g_2~A}\map \\
			\B' & \sigma~(range~g')
		}{pre@ap~(pre~g'~\B')~B}
\\
	&\tab \equiv \ preimage~\pair{g_1~A,g_2~A}\map~B
\end{align*}
Next, we apply Theorem~\ref{thm:preimage-mapping-pairing} with $\B_1' = trace~\B_1~(range~g_1')$ and $\B_1 = trace~\Un~Y$ (similarly for $\B_2'$ and $\B_2$), and rewrite in terms of $\arrpre$:
\begin{align*}
	&pre@ap~(\arrpre~(\pairmap~g_1~g_2)~A)~B
\\
	&\tab \equiv \ 
		\lzfclet{
			g_1' & g_1~A \\
			\B_1' & \sigma~(range~g_1') \\
			h_1 & pre~g_1'~\B_1' \\
			g_2' & g_2~A \\
			\B_2' & \sigma~(range~g_2') \\
			h_2 & pre~g_2'~\B_2'
		}{pre@ap~\pair{h_1, h_2}\pre~B}
\\
	&\tab \equiv \
		\lzfclet{
			h_1 & \arrpre~g_1~A \\
			h_2 & \arrpre~g_2~A \\
		}{pre@ap~\pair{h_1, h_2}\pre~B}
\numberthis
\end{align*}
Substituting $h_1$ for $\arrpre~g_1$ and $h_2$ for $\arrpre~g_2$ in the last equality gives a definition for $\pairpre$ for which~\eqref{eqn:arrpre-distributes-over-pairmap} holds:
\begin{equation}
\begin{aligned}
	&\pairpre : (X \preto Y) \tto (X \preto Z) \tto (X \preto Y \times Z) \\
	&\pairpre~h_1~h_2~A \ := \ \pair{h_1~A,h_2~A}\pre
\end{aligned}
\end{equation}

\subsection{Case: Composition}

Let $\C$ be a $sigma$-algebra on $Z$.
Starting with the left-hand side of~\eqref{eqn:arrpre-distributes-over-compmap}, we expand definitions and apply Theorem~\ref{thm:pre-like-preimage}:
\begin{align*}
	&pre@ap~(\arrpre~(\compmap~g_1~g_2)~A~\C)~C
\\
	&\tab \equiv \ 
		\lzfclet{
			g_1' & g_1~A \\
			g_2' & g_2~(range~g_1') \\
			g' & g_2' \circ\map g_1' \\
			\C' & \sigma@trace~\C~(range~g')
		}{pre@ap~(pre~g'~\C)~C}
\\
	&\tab \equiv \
		\lzfclet{
			g_1' & g_1~A \\
			g_2' & g_2~(range~g_1')
		}{preimage~(g_2' \circ\map g_1')~C}
\numberthis
\end{align*}
Next, we apply Theorem~\ref{thm:preimage-mapping-composition} and rewrite in terms of $\arrpre$:
\begin{align*}
	&pre@ap~(\arrpre~(\compmap~g_1~g_2)~A)~C
\\
	&\tab \equiv \ 
		\lzfclet{
			g_1' & g_1~A \\
			\B & \sigma~(range~g_1') \\
			h_1 & pre~g_1'~\B \\
			g_2' & g_2~(range~g_1') \\
			\C & \sigma~(range~g_2') \\
			h_2 & pre~g_2'~\C
		}{pre@ap~(h_2 \circ\pre h_1)~C}
\\
	&\tab \equiv \
		\lzfclet{
			h_1 & \arrpre~g_1~A \\
			h_2 & \arrpre~g_2~(range~(g_1~A))
		}{pre@ap~(h_2 \circ\pre h_1)~C}
\\
	&\tab \equiv \
		\lzfclet{
			h_1 & \arrpre~g_1~A \\
			h_2 & \arrpre~g_2~(\U (domain~h_1))
		}{pre@ap~(h_2 \circ\pre h_1)~C}
\numberthis
\end{align*}
Substituting $h_1$ for $\arrpre~g_1$ and $h_2$ for $\arrpre~g_2$ in the last equality gives the definition for $\comppre$:
\begin{equation}
\begin{aligned}
	&\comppre : (X \preto Y) \tto (Y \preto Z) \tto (X \preto Z) \\
	&\comppre~h_1~h_2~A \ := \ 
		\lzfclet{
			h_1' & h_1~A \\
			h_2' & h_2~(\U (domain~h_1'))
		}{h_2 \circ\pre h_1}
\end{aligned}
\end{equation}


\subsection{Case: Conditional}

Starting with the left-hand side of~\eqref{eqn:arrpre-distributes-over-ifmap}, expanding terms, and applying Theorem~\ref{thm:pre-like-preimage} results in
\begin{align*}
	&pre@ap~(\arrpre~(\ifmap~g_1~g_2~g_3)~A)~B
\\
	&\tab \equiv \
		\lzfclet{
			g_1' & g_1~A \\
			g_2' & lazy\map~(g_2~0)~(preimage~g_1'~\set{true}) \\
			g_3' & lazy\map~(g_3~0)~(preimage~g_1'~\set{false})
		}{preimage~(g_2' \uplus\map g_3')~B}
\end{align*}
Next, we apply Theorem~\ref{thm:piecewise-preimage-mappings} and rewrite in terms of $\arrpre$:
\begin{align*}
	&pre@ap~(\arrpre~(\ifmap~g_1~g_2~g_3)~A)~B
\\
	&\tab \equiv \ 
		\lzfclet{
			g_1' & g_1~A \\
			g_2' & lazy\map~(g_2~0)~(preimage~g_1'~\set{true}) \\
			\B_2 & \sigma~(range~g_2') \\
			h_2 & pre~g_2~\B_2 \\
			g_3' & lazy\map~(g_3~0)~(preimage~g_1'~\set{false}) \\
			\B_3 & \sigma~(range~g_3') \\
			h_3 & pre~g_3~\B_3
		}{pre@ap~(h_2 \uplus\pre h_3)~B}
\\
	&\tab \equiv \ 
		\lzfclet{
			g_1' & g_1~A \\
			h_2 & \arrpre~(lazy\map~(g_2~0))~(preimage~g_1'~\set{true}) \\
			h_3 & \arrpre~(lazy\map~(g_3~0))~(preimage~g_1'~\set{false})
		}{pre@ap~(h_2 \uplus\pre h_3)~B}
\\
	&\tab \equiv \ 
		\lzfclet{
			h_1 & \arrpre~g_1~A \\
			h_2 & \arrpre~(lazy\map~(g_2~0))~(pre@ap~h_1~\set{true}) \\
			h_3 & \arrpre~(lazy\map~(g_3~0))~(pre@ap~h_1~\set{false})
		}{pre@ap~(h_2 \uplus\pre h_3)~B}
\end{align*}
Suppose we have defined $lazy\pre$ so that for any domain subset $A$,
\begin{equation}
	\arrpre~(lazy\map~g)~A \ \equiv \ lazy\pre~(\arrpre~g)~A
\label{eqn:arrpre-distributes-over-lazymap}
\end{equation}
(We discharge this proof obligation after defining $\ifpre$.)
Then
\begin{align*}
	&pre@ap~(\arrpre~(\ifmap~g_1~g_2~g_3)~A)~B
\\
	&\tab \equiv \ 
		\lzfclet{
			h_1 & \arrpre~g_1~A \\
			h_2 & lazy\pre~(\arrpre~(g_2~0))~(pre@ap~h_1~\set{true}) \\
			h_3 & lazy\pre~(\arrpre~(g_3~0))~(pre@ap~h_1~\set{false})
		}{pre@ap~(h_2 \uplus\pre h_3)~B}
\end{align*}
Substituting $h_1$ for $\arrpre~g_1$, $h_2~0$ for $\arrpre~(g_2~0)$, and $h_3~0$ for $\arrpre~(g_3~0)$ in the last equality gives the definition for $\ifpre$.

Lastly, starting with the left-hand side of~\eqref{eqn:arrpre-distributes-over-lazymap},
\begin{align*}
	&\arrpre~(lazy\map~g)~A \ \equiv \ 
\\
	&\tab \equiv \
		\lzfclet{
			g' & if~(A = \emptyset)~\emptyset~(g~A) \\
			\B & \sigma~(range~g')
		}{pre~g'~\B}
\\
	&\tab \equiv \ if~(A = \emptyset)~(pre~\emptyset~(\sigma~\emptyset))~(\arrpre~g~A)
\\
	&\tab \equiv \ if~(A = \emptyset)~(\fun{\emptyset}{\emptyset})~(\arrpre~g~A)
\end{align*}
Substituting $h$ for $\arrpre~g$ in the last equality gives the definition for $lazy\pre$.


\subsection{Super-Saver Theorems}

The following two theorems are easy consequences of the fact that $\arrpre$ is a natural transformation.

\begin{corollary}
$\arrpre$, $\pairpre$ and $\comppre$ define an arrow.
\end{corollary}

\begin{corollary}
Let $g : X \mapto Y$ and $h : X \preto Y$ such that $h \ \eqmap \ \arrpre~g$.
Then for all $A \subseteq X$, $h~A$ diverges if and only if $g~A$ diverges.
\end{corollary}

XXX: simple reason for this:
\begin{corollary}
XXX: measurability
\end{corollary}


\section{Preimages of Partial Functions}

\begin{equation}
\begin{aligned}
	&\bot\pre : X \preto \emptyset \\
	&\bot\pre \ := \ \arrpre~(\arrmap~\fun{x}\bot)
\end{aligned}
\end{equation}


%\appendix
%\section{Appendix Title}
%This is the text of the appendix, if you need one.

%\acks
%Acknowledgments, if needed.

\bibliographystyle{abbrvnat}
\bibliography{plt}

\end{document}
